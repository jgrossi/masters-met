<?xml version="1.0"?>
<pdf>
  <title line_height="12.64" font="Times-Bold">Programming Without a Computer: A New
Interface for Children under Eight</title>
  <section line_height="8.96" font="Times-Italic" letter_ratio="0.03"
year_ratio="0.0" cap_ratio="0.05" name_ratio="0.25748502994011974" word_count="167"
lateness="0.125" reference_score="1.86">Abstract Electronic Blocks are a new
programming interface, designed for children aged between three and eight years. The
Electronic Blocks programming environment includes sensor blocks, action blocks and
logic blocks. By connecting these blocks children can program structures that
interact with the environment. The Electronic Block programming interface design is
based on principles of developmentally appropriate practices in early childhood
education. As a result the blocks provide young children with a programming
environment that allows them to explore quite complex programming principles. The
simple syntax of the blocks provides opportunities for young children unavailable
through the use of traditional programming languages. The blocks allow children to
create and use simple code structures. The Electronic Block environment provides a
developmentally appropriate environment for planning overall strategies for solving a
problem, breaking a strategy down into manageable units, and systematically
determining the weakness of the solution. Electronic Blocks are the physical
embodiment of computer programming. They have the unique dynamic and programmable
properties of a computer minus its complexity.<component x="57.88" y="283.96"
width="236.92" height="275.22" page="1" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.03" name_ratio="0.2616487455197133" word_count="279" lateness="0.125"
reference_score="1.28">Electronic Blocks aim to provide young children, aged between
three and eight years of age, with a new interface for exploring programming
concepts. Electronic Blocks represent a paradigm shift, away from using the computer
to teach programming, towards a physically embodied system that provides programming
experiences that involve active manipulation and transformational of real materials.
This programming interface has been designed to take into account the special needs
of children under eight and has been based on early childhood development and
learning research. Electronic Blocks are blocks with electronic circuits inside them.
By placing electronic blocks on top of one another young children build the
equivalent of c"omputer programs." Sensors and effectors built into the blocks allow
children to build structures that interact with the environment. The sensor blocks
detect light, sound and touch while the effector or action blocks are capable of
producing light, sound and movement. By connecting sensor blocks with action blocks
children can program their own structures. They might create a group of r"obots" and
these robots might wink at each other, move when they hear sound, or be capable of
following a light. There are also logic blocks which logically negate, delay, and,
and toggle signals between sensor blocks and action blocks. The inclusion of these
blocks adds an additional dimension to the capabilities of the childrens' creations.
The design of these blocks has now been completed and the implementation phase of the
Electronic Block project is nearing the completion. Once successfully implemented,
the Electronic Blocks will be extensively evaluated. This evaluation has been
designed to explore the extent to which electronic blocks allow children to explore
programming concepts as hypothesised in this paper.<component x="57.88" y="85.72"
width="236.86" height="146.96" page="1" page_width="612.0"
page_height="792.0"></component><component x="317.34" y="320.8" width="237.21"
height="238.88" page="1" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.02" name_ratio="0.2587800369685767" word_count="541" lateness="0.25"
reference_score="2.19">When computers were first introduced in early childhood
settings, there was a propensity for using the computer as a tool to reinforce
existing practices, facilitating activities such as reading, writing and mathematics.
This mechanistic style of computer use, still seen to some extent in schools, led
educators to ask whether or not computer-based activities offer anything that is
substantially different from what can be obtained in the classroom by other means
[13][3][14]. The answer for some has been for educational institutions to embrace
computer use that offers opportunities for children to explore the computers' unique
dynamic and programmable properties. From as early as 1980, with the groundbreaking
work of Papert [9], researchers recognised that computer programming as an
educational activity had great potential as a vehicle for the acquisition of useful
cognitive skills such as problem solving and reflective thinking. The research
outlined in this paper follows this school of thought. It is widely acknowledged that
while computers can have many functions within an early education setting, its power
as a tool for technology education lies in the programmable and dynamic properties
unique to it. It is these properties which make it different from other media with
which children interact. This type of computer exploration allows children to become
involved in technology in a way recommended by Raizen et al. [10]. Computer
programming requires children to use their intellectual resources while involved in
processes such as designing, producing and using, to create systems and structures.
Programming also provides the opportunity for children to become involved in s"eeing
and constructing in terms of new formal knowledge of how things are put together"
[7]. For over a decade researchers a MIT Media Laboratory have been studying the
richness of experiences that involve exploration of the dynamic and programmable
properties of a computer. The strong belief that children benefit greatly from
becoming creators, not just consumers, of computer activities, drives their research.
It is a philosophy embraced by the research discussed in this paper. Programming a
computer allows children to have an impact on the technology they are using, they
become the creators, and they are in control. Through learning to program a computer
children develop a much deeper relationship with, and consequently deeper
understanding of, the computer [12]. Unfortunately for young children, the ideas
about instructions and sequence, which form the core of programming, are not
necessarily simple. At a time when young children are only just acquiring the
rudiments of notational systems and are struggling with symbolisation in language
[13], it would be unreasonable to expect them to cope with the symbolic systems
required to successfully program a computer. In addition, programming languages are
artificial rather than natural languages and consequently, they have a different
epistemology that deals with the unfamiliar world of computer data structures and
algorithms [15]. This makes them even more difficult to learn. As an alternative to
the computer, Electronic Blocks are designed to provide preschool and early primary
school children with a resource that has the unique dynamic and programmable
properties of a computer minus its complexity. Electronic Blocks are the physical
embodiment of computer programming. They are naturally less complex to program than a
computer as they do not require a knowledge of complex symbolic systems.<component
x="317.44" y="88.0" width="237.1" height="181.4" page="1" page_width="612.0"
page_height="792.0"></component><component x="57.88" y="122.4" width="237.18"
height="595.39" page="2" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.07" name_ratio="0.3448275862068966" word_count="29" lateness="0.25"
reference_score="2.69">The Electronic Block programming interface incorporates two
sets of design criteria, those that ensure the age-appropriateness of the design and
those that capture the programmable elements of a computer.<component x="317.44"
y="634.79" width="237.24" height="43.4" page="2" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.05" name_ratio="0.20491803278688525" word_count="244" lateness="0.25"
reference_score="3.23">In order to meet principles of developmentally appropriate
practices that reflect current knowledge and beliefs about what constitutes high
quality, developmentally appropriate early childhood education, the design of
Electronic Blocks must ensure: 1. activities are open-ended and discovery-oriented,
allowing children to be actively involved in the learning process; 2. interaction
encourages child-initiated play; 3. experiences involve active manipulation and
transformation of real materials; 4. entry level knowledge and experience is kept to
a minimum; 5. provision is made for childrens' varied skill and ability levels; 6.
construction activities that involve design, creation and evaluation processes form
the basis of interactions. (based on Bredekamp and Copple [2]) Applying the
principles of developmentally appropriate practices, aims to ensure that the
Electronic Blocks are a developmentally appropriate resource for providing
programming experiences to children under the age of eight. In addition, in order to
create a programmable resource, electronic blocks have been designed using guidelines
outlined by Resnick [11]. These guidelines have formed the basis of the following
design criteria. Electronic Blocks need to: 7. be non-algorithmic - the path of
action is not fully specified in advance; 8. be complex - the total path is not
visible; 9. incorporate uncertainty - not everything that bears on the task at hand
is known; 10. allow users to find structure in apparent disorder; 11. yield multiple
solutions, each with costs and benefits. These 11 design criteria have formed the
platform on which the Electronic Blocks have been based.<component x="317.44"
y="161.64" width="237.04" height="434.48" page="2" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.06" name_ratio="0.22377622377622378" word_count="143" lateness="0.375"
reference_score="4.14">The Electronic Blocks have been designed so children can
connect them just as they would any other blocks. The blocks have been made by
placing electronics inside Lego TM Duplo Primo blocks. This ensures that the blocks
are easy to stack and connect. Electronic Blocks have inputs and outputs and when
connected, the output of one block controls the input of another. There are three
kinds of electronic blocks: sensor blocks, action blocks and logic blocks. Sensor
blocks detect light, touch and sound within the environment. Action blocks produce
some kind of output: a light block produces light, while a movement block is capable
of motion. The sensor blocks will provide the signals that make the action blocks
a"ct". Logic blocks have an intermediary role. Placed between a sensor block and an
action block they have the ability to alter the expected action.<component x="317.44"
y="89.87" width="236.79" height="31.88" page="2" page_width="612.0"
page_height="792.0"></component><component x="57.88" y="559.32" width="236.98"
height="160.65" page="3" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.06" name_ratio="0.19387755102040816" word_count="98" lateness="0.375"
reference_score="4.55">There are three Electronic Sensor Blocks: a seeing block, a
hearing block and a touch block. These blocks are capable of detecting light, sound
and touch, respectively. They are single connector blocks that have an input attached
to the upper connector and an output attached to the lower connector (see Figure 1).
The input is off unless it explicitly receives an on signal. The input and the sensor
are ORed together to produce the output. As a result when two or more sensor blocks
are stacked on an action block any sensor input will trigger the action
block.<component x="57.88" y="408.24" width="236.87" height="112.4" page="3"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.03" name_ratio="0.20833333333333334" word_count="96" lateness="0.375"
reference_score="3.66">Action blocks produce some kind of output. The light block
produces light, the sound block produce sound and the movement block is capable of
motion. All action blocks are double connector blocks (see Figure 1). They are
physically constrained by a base plate so that they cannot be placed on top of
another block and have to be positioned at the bottom of a block stack. The two upper
connectors may receive an input signal. Each action block works as an OR - the action
takes place if the block receives input from either upper connector.<component
x="57.88" y="257.04" width="237.32" height="112.52" page="3" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.04" name_ratio="0.24778761061946902" word_count="113" lateness="0.375"
reference_score="4.0">With the exception of the and block, these blocks are single
connector blocks with an input attached to the upper connector and an output attached
to the lower connector (see Figure 1). The input of the not, toggle, and delay blocks
is off unless an on signal is received. An on signal will produce an output relative
to the logic of the block. The and block, a double connector block, has two upper
connectors which may receive an input signal (see Figure 1). The block works as a
logical AND - it must receive an input from both connectors to produce an output. The
output signal produced is attached to both lower connectors.<component x="57.88"
y="82.92" width="236.91" height="135.44" page="3" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.02" year_ratio="0.0"
cap_ratio="0.0" name_ratio="0.2222222222222222" word_count="45" lateness="0.375"
reference_score="2.39">Children of all ages are capable of programming using the
electronic blocks. They have been designed to be used by children across the early
childhood spectrum - children under five who are not engaged in the formal education
process as well as school aged children.<component x="317.44" y="250.56"
width="236.94" height="55.04" page="3" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="9.94" font="Times-Bold" letter_ratio="0.09" year_ratio="0.0"
cap_ratio="0.11" name_ratio="0" word_count="9" lateness="0.375"
reference_score="6.37">4.1. Pre-schoolers Programming ~ simple constructions
producing simple behaviours<component x="317.44" y="213.49" width="224.82"
height="22.54" page="3" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.03" name_ratio="0.2537313432835821" word_count="67" lateness="0.5"
reference_score="4.21">their touch. These are examples of simple sensor-action
combinations. Given a set of three sensor blocks and three action blocks, there are a
total of nine such combinations. While young children are becoming used to the
functionality of Electronic Blocks it may be advantageous to limit interactions to
these simple input-output combinations. Logic blocks may be added when children
demonstrate confidence using the sensor and action blocks.<component x="57.88"
y="616.92" width="237.15" height="100.88" page="4" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.02" year_ratio="0.0"
cap_ratio="0.01" name_ratio="0.2857142857142857" word_count="154" lateness="0.5"
reference_score="3.31">The addition of logic blocks to the set of Electronic Blocks
opens up a wide variety of additional construction opportunities. Logic blocks
provide users with the capability to: only produce an action if two input signals are
&#x2022; received simultaneously, produce an action if a particular stimulus is not
&#x2022; received, add a time delay between the sensor input and the &#x2022; desired
action, and toggle the input so that in the first instance the &#x2022; stimulus from
the environment will t"urn the action on" and the second instance of the stimulus
will "turn the action off". A task that sees the introduction of a logic block is the
creation of a car that starts when you clap and stops when you clap again. A toggle
block placed between a hearing block and a movement block will achieve this result.
Logic blocks add to the complexity and variety of structures that may be
created.<component x="57.88" y="347.89" width="237.07" height="230.34" page="4"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.04" name_ratio="0.17647058823529413" word_count="102" lateness="0.5"
reference_score="4.67">A fascinating aspect of Electronic Blocks is their ability to
interact not only with the environment but also with each other. An example of two
Electronic Block structures interacting is the creation of a remote control car. By
creating one block stack which contains a touch block and a light block and another
stack which has a seeing block on top of a movement block, a child has effectively
created a remote control car. By pressing the touch block, the child triggers the
light. This light in turn is detected as an input by the seeing block which actives
the movement block.<component x="57.88" y="184.08" width="237.07" height="112.4"
page="4" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.07" name_ratio="0.2523364485981308" word_count="214" lateness="0.5"
reference_score="5.18">Programming is generally thought of in terms of code writing
and debugging - in essence consisting of a" series of written instructions that make
a computer accomplish a task" (Pea and Kurland, 1984 as cited in [8]). However, in
recent years, the changing nature of computer interfaces has lead people to question
this definition of programming. Given the development of direct TM manipulation
programming languages such as ToonTalk [6] and Cocoa [15], the acceptance of
l"anguageless" programming as a legitimate alternative for the purpose of teaching
programming is gaining momentum. In addition to w"riting code " programming is about
defining a problem and being able to generate effective programming approaches with
an awareness of the alternatives that are most appropriate. A programmer needs to
design a solution based on a hypothesis of how the problem will best be solved.
Developing a solution requires an evaluation of alternate strategies and careful
planning of the steps required to achieve this solution. Subsequent testing is
required to determine the strengths and weaknesses of the original hypothesis. These
are the skills that the Electronic Blocks programming environment aim to promote. In
analysing the extent to which Electronic Blocks can promote the development of such
programming skills the following hierarchy (developed by Oakley and McDougall [8])
has been used:<component x="57.88" y="86.99" width="236.82" height="43.4" page="4"
page_width="612.0" page_height="792.0"></component><component x="317.44" y="455.88"
width="237.09" height="261.92" page="4" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.02" year_ratio="0.0"
cap_ratio="0.07" name_ratio="0.2857142857142857" word_count="28" lateness="0.5"
reference_score="4.71">Each of these skills is examined with respect to how it can be
achieved more readily using Electronic Blocks than by the use of a traditional
programming language.<component x="317.44" y="327.96" width="236.94" height="32.0"
page="4" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.01" name_ratio="0.2033898305084746" word_count="354" lateness="0.625"
reference_score="4.95">The syntax of Electronic Blocks is very simple. In order to
produce some kind of behaviour children must 1. Include an action block in the block
stack. 2. Include a sensor block in the block stack. 3. Place the action block at the
bottom of a block stack. All action blocks are physically constrained by a base plate
ensuring that they cannot be placed on top of another block. Therefore, creating a
block stack to produce a behaviour is simple. All that is required is one sensor
block and one action block. A child can create a car that moves in a bright
environment by placing a seeing block on top of a movement block. By placing a touch
block on a light block a child has created a camera flash - the light flashes when
they hit the button. In order to use logic blocks successfully children need to
understand that: 1. Logic blocks alter the signal they receive from the blocks above
them. If they are at the top of a block stack they will not effect the operation of
that stack. 2. If two sensor blocks are placed on top of a logic block then the logic
block will perform the logic operation when either environmental condition is met. In
the example in Figure 2 the light will turn on in the dark (ie. not light) or when
not touched. Either condition effects the behaviour of the action block. Logic blocks
increase the complexity of electronic block syntax. The order of placement of the
logic blocks within a program stack is an important consideration, as each change in
order has the potential to yield a different outcome. Fortunately, even with this
increase in complexity, two factors make it possible to work through logic issues
using trial and error. Firstly, any solution stack that has a sensor block and an
action block yields a testable behaviour. This allows the child to easily determine
the impact of a logic block in a stack. Secondly, changing a program stack is a
relatively straightforward operation - simply pulling the blocks apart and reordering
the stack.<component x="317.44" y="107.88" width="236.72" height="181.4" page="4"
page_width="612.0" page_height="792.0"></component><component x="57.88" y="467.4"
width="237.03" height="250.75" page="5" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.02" year_ratio="0.0"
cap_ratio="0.03" name_ratio="0.2903225806451613" word_count="62" lateness="0.625"
reference_score="4.76">Compared with the syntax of even the simplest computer
programming language, the syntax of electronic blocks are significantly less complex.
This lack of complexity ensures that Electronic Blocks provide a powerful platform
for teaching children fundamental programming concepts. Reducing the complexity of
the syntax provides children with greater opportunities to focus on high-level
programming concepts such as debugging, planning and evaluating strategies.<component
x="57.88" y="130.56" width="237.1" height="100.88" page="5" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.01" name_ratio="0.2413793103448276" word_count="348" lateness="0.625"
reference_score="4.58">An important issue in learning to program is program design -
successful mapping between problem domain and program domain (as defined by Brooks
cited in [4]). Research indicates that end user programmers have difficulty dealing
with entities in the program domain that do not have corresponding entities in the
problem domain and an abundance of low level primitives is one of the great cognitive
barriers to programming (for a review of this research see [4]). Given the cognitive
limitations of young children, it may be concluded that such difficulties would be
amplified. An important consideration, then, for creating a programming environment
for young children, is the inclusion of entities that map directly back to the
problem domain. Electronic blocks represent such entities. If a child wishes to
create a robot that sings in the light, then it is a simple matter of mapping the
problem to the blocks available. That child will need to include a seeing block so
the robot can tell whether it is light or dark and a noise block to create the sound.
If that child then wanted to create a robot that does not sing in the light it is a
matter of adding a not block to the program stack. If the child wants the robot to
sing in the light after a delay they just need to add a delay block. This
task-oriented style of programming makes the coding of simple structures relatively
simple. Each entity in the Electronic Block system maps directly to the problem
domain. While new task-specific visual programming languages are being designed to
address this issue, most computer programming languages are full of low-level
primitives that do not map directly back to the problem domain. The act of coding a
simple structure in most programming languages requires a knowledge of low-level
primitives and how they should be combined to achieve the desired result. Given that
young children rely more on their visual and auditory perception for knowledge than
they do on logical thought processes [5] it is understandable that they find type of
programming is extremely difficult.<component x="317.44" y="247.2" width="237.25"
height="446.0" page="5" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.04" name_ratio="0.1523809523809524" word_count="105" lateness="0.625"
reference_score="5.87">A child can create a camera flash by placing a touch block on
top of a light block. They can create a remote control car by placing a seeing block
on a movement block and then using the camera flash as the remote control (see Figure
3). Pressing the touch sensor would result in a light turning on. This light would be
sensed by the seeing block, which would in turn trigger the movement of the movement
block. A remote control vehicle has been created. This is an example of a way in
which Electronic Blocks allow children to reuse simple c"ode structures." The
same<component x="317.44" y="84.6" width="237.25" height="123.92" page="5"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.14" year_ratio="0.0"
cap_ratio="0.5" name_ratio="0" word_count="2" lateness="0.75"
reference_score="18.17">Movement Block<component x="110.2" y="500.87" width="43.21"
height="20.48" page="6" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.18" year_ratio="0.0"
cap_ratio="0.5" name_ratio="0" word_count="2" lateness="0.75"
reference_score="19.26">Light Block<component x="225.16" y="494.15" width="23.94"
height="20.72" page="6" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.05" name_ratio="0.23711340206185566" word_count="194" lateness="0.75"
reference_score="6.8">A programmer must plan the overall strategy for solving a
problem, break this strategy down into manageable units, and to systematically seek
out weakness in ones' reasoning. The Electronic Block programming environment
provides the opportunity for children to become involved in this type of planning
activity. To illustrate this point, the example of creating robots that wink at each
other is used. Initially a child might create two program stacks, each containing a
seeing block and a light block. The light block represents the "wink". This solution
has a problem. Neither robot will initiate the winking sequence. Both are sitting
waiting for a light input. The solution may involve the addition of a not block to
one of the stacks. This modification to Robot1 will result in it starting the winking
sequence. When Robot2 winks in response, Robot1 will sense the presence of the light
and its light will turn off. As a result Robot2s' light will then turn off. This
results in a wink by Robot1, and the process is repeated. This solution might be
further improved by the addition of a delay block to Robot2. This solution is
illustrated in Figure 4.<component x="317.44" y="316.2" width="237.1" height="250.52"
page="6" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.01" name_ratio="0.2" word_count="140" lateness="0.875"
reference_score="6.82">The emergent nature of the problem makes it an ideal
programming task for children. The path of action is not fully specified in advance,
nor is it visible. Children are required to make a plan of action, evaluate each step
through testing their solution and make any necessary adjustments. Possessing
strategies for planning and debugging is a prerequisite for programming success. Many
bugs arise as a result of plan composition problems - difficulties in putting the
p'ieces ' of a program together [4]. Electronic Blocks avoid this difficulty because
each piece of a program works independently and each step towards a solution may
easily be tested. In addition, research suggests that using spatial reasoning for
support may be useful in the planning and debugging processes [4]. Electronic Blocks
provide more scope for visual and spatial reasoning than text based
languages.<component x="57.88" y="524.88" width="237.24" height="192.92" page="7"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.05" name_ratio="0.25190839694656486" word_count="131" lateness="0.875"
reference_score="7.14">There are many Electronic Block programming tasks that have
multiple solutions, each with costs and benefits. As a physically embodied
programming environment, Electronic Blocks provide a powerful means for evaluating
alternate strategies. Children, unsure of the best solution, may easily build two
solutions concurrently, and then compare and contrast them. While young children
might struggle to logically analyse the positives and negatives of alternative
strategies (as may be required with a traditional programming language), their
natural curiosity and inherent desire to construct their own understanding of the
world, acts as a driving force in the exploration of such alternatives with
Electronic Blocks. Children are true scientific explorers of their environment and
within a nonthreatening environment that encourages autonomy, children will naturally
seek alternate strategies and test the limits of their creations.<component x="57.88"
y="293.28" width="237.24" height="192.92" page="7" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.06" name_ratio="0.2653061224489796" word_count="49" lateness="0.875"
reference_score="7.33">Electronic Blocks are physically embodied and consequently
will provide experiences that involve active manipulation and transformational of
real materials. The Electronic Blocks are undeniably a resource that allows children
to work both autonomously and actively, and the variety of expressive opportunities
they offer guarantees open-ended, discovery oriented learning experiences.<component
x="57.88" y="175.44" width="236.89" height="77.96" page="7" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.08" name_ratio="0.2619047619047619" word_count="126" lateness="0.875"
reference_score="7.78">The examples of programming outlined above show that children
can use the Electronic Block programming environment independently to build programs.
The theory of developmentally appropriate practice utilised in the design of the
electronic blocks guarantees a learning environment where children can experience
programming unimpeded. Alan Kay of the Apple Research Laboratory identified this as
of key significance. O"ne of the things I have been interested in for many years
&#x2026; is the possibility of giving young kids direct access to interesting ideas
via an interface that does not require the mediation of adults at all." [7] The
Electronic Block programming interface is simple to master and while things might not
always go to plan, making adjustments is as easy as pulling blocks apart and
rebuilding them.<component x="57.88" y="81.84" width="237.05" height="54.92" page="7"
page_width="612.0" page_height="792.0"></component><component x="317.44" y="570.84"
width="236.99" height="146.96" page="7" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.06" name_ratio="0.26666666666666666" word_count="135" lateness="0.875"
reference_score="7.44">In designing the Electronic Blocks consideration has been
given to providing a number of levels at which children can work. They can be used as
"normal" building blocks or provide challenges through the use of logic blocks and
through the creation of structures that interact. The flexibility - with respect to
skill and ability levels with which the Electronic Blocks have been designed, makes
them a powerful resource for teaching programming concepts. However, it is the more
complex interactions with Electronic Blocks, the use of logic blocks and interacting
block structures, which provide the greatest opportunities to learn about
programming. Examples outlined throughout the paper, demonstrate how the simplicity
of Electronic Block syntax allows for significant opportunities to explore
programming concepts such as defining a problem, planning the solution, testing and
debugging, and evaluating alternatives.<component x="317.44" y="326.64"
width="237.12" height="192.92" page="7" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.06" name_ratio="0.2857142857142857" word_count="70" lateness="0.875"
reference_score="7.17">Theoretical evidence points to the Electronic Blocks being a
powerful tool for young children to experience programming without the use of a
computer. The next step in this project is to carry out evaluations in school
settings to the test this hypothesis. The Electronic Blocks are currently being
implemented following the design outlined in this paper. They will be taken into both
preschool and primary school settings for complete evaluation.<component x="317.44"
y="185.76" width="237.07" height="89.48" page="7" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.1" font="Times-Roman" letter_ratio="0.23" year_ratio="0.04"
cap_ratio="0.42" name_ratio="0.125" word_count="376" lateness="1.0"
reference_score="29.13">[1] Adams, T. (1996). Logo environments: The evolution of the
language. In J. Oakley (ed.), Logo in Australia: Selected readings (pp. 1-16).
Richmond, Vic: Computing in Education Group of Victoria. [2] Bredekamp, S., &amp;
Copple, C. (Eds.). (1997). Developmentally appropriate practice in early childhood
education. (Revised ed.). Washington, D.C.: National Association for the Education of
Young Children. [3] Cuffaro, H. K. (1984). Microcomputers in education: Why is
earlier better? Teachers College Record, 85, 559-568. [4] Green, T. R. G., &amp;
Petre, M. (1996). Usability analysis of visual programming environments: A 'cognitive
dimensions' framework. Journal of Visual Languages and Computing, 7, 131174. [5]
Gullo, D. F. (1992). Development and characteristics of kindergarten-age children. In
L. R. Williams, &amp; D. P. Fromberg (eds.), Encyclopaedia of early childhood
education (pp 206-207). New York: Garland Publishing Inc. TM - An animated
programming [6] Kahn, K. (1996). ToonTalk environment for children. Journal of Visual
Languages and Computing, 7, 197-217. [7] Kay, A. (1994). Observations about children
and computers. Advanced Technology Group, Learning Concepts Group, Apple Research
Laboratory Research Note No. 31. [Online]. Available:
http://www.atg.apple.com/technology/reports/RN31.html [8] Oakley, J., &amp;
McDougall, A. (1997). Young children as programmers: Fantasy or flight. In A.
McDougall, &amp; C. Dowling (Eds.), Learning in Logo microworlds. Richmond, Vic:
Computing in Education Group of Victoria. [9] Papert, S. (1980). Mindstorms:
Children, computers and powerful ideas. New York: Basic Books. [10] Raizen, S. A.,
Sellwood, P., Todd, R. D., &amp; Vickers, M. (1995). Technology education in the
classroom: Understanding the designed world. San Francisco: Jossey-Bass Publishers.
[11] Resnick, L. (1987). Education and learning to think. Committee on Mathematics,
Science, and Technology Education, Commission on Behavioural and Social Sciences and
Education, National Research Council. Washington, D.C.: National Academy Press. [12]
Resnick, M., Bruckman, A., &amp; Martin, F. (1996) Pianos not stereos: Creating
computational construction kits. Interactions, 3 (5), 41-50. [13] Sheingold, K.
(1987). The microcomputer as a symbolic medium. In R. D. Pea, &amp; K. Sheingold
(Eds.), Mirrors of minds: Patterns of experience in educational computing (pp
198-208). Norwood, NJ: Ablex Publishing Corporation. [14] Sloan, D. (1984). On
raising critical questions about the computer in education. Teachers College Record,
85, 539-547. [15] Smith, D. C., Cypher, A., &amp; Schmucker, K. (1996). Making
programming easier for children. Interactions, September - October, 59-67.<component
x="317.44" y="86.26" width="236.78" height="59.82" page="7" page_width="612.0"
page_height="792.0"></component><component x="57.88" y="254.48" width="237.39"
height="463.51" page="8" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Italic" letter_ratio="0.03"
year_ratio="0.0" cap_ratio="0.05" name_ratio="0.25748502994011974" word_count="167"
lateness="0.125" reference_score="1.86">Abstract Electronic Blocks are a new
programming interface, designed for children aged between three and eight years. The
Electronic Blocks programming environment includes sensor blocks, action blocks and
logic blocks. By connecting these blocks children can program structures that
interact with the environment. The Electronic Block programming interface design is
based on principles of developmentally appropriate practices in early childhood
education. As a result the blocks provide young children with a programming
environment that allows them to explore quite complex programming principles. The
simple syntax of the blocks provides opportunities for young children unavailable
through the use of traditional programming languages. The blocks allow children to
create and use simple code structures. The Electronic Block environment provides a
developmentally appropriate environment for planning overall strategies for solving a
problem, breaking a strategy down into manageable units, and systematically
determining the weakness of the solution. Electronic Blocks are the physical
embodiment of computer programming. They have the unique dynamic and programmable
properties of a computer minus its complexity.<component x="57.88" y="283.96"
width="236.92" height="275.22" page="1" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.03" name_ratio="0.2616487455197133" word_count="279" lateness="0.125"
reference_score="1.28">Electronic Blocks aim to provide young children, aged between
three and eight years of age, with a new interface for exploring programming
concepts. Electronic Blocks represent a paradigm shift, away from using the computer
to teach programming, towards a physically embodied system that provides programming
experiences that involve active manipulation and transformational of real materials.
This programming interface has been designed to take into account the special needs
of children under eight and has been based on early childhood development and
learning research. Electronic Blocks are blocks with electronic circuits inside them.
By placing electronic blocks on top of one another young children build the
equivalent of c"omputer programs." Sensors and effectors built into the blocks allow
children to build structures that interact with the environment. The sensor blocks
detect light, sound and touch while the effector or action blocks are capable of
producing light, sound and movement. By connecting sensor blocks with action blocks
children can program their own structures. They might create a group of r"obots" and
these robots might wink at each other, move when they hear sound, or be capable of
following a light. There are also logic blocks which logically negate, delay, and,
and toggle signals between sensor blocks and action blocks. The inclusion of these
blocks adds an additional dimension to the capabilities of the childrens' creations.
The design of these blocks has now been completed and the implementation phase of the
Electronic Block project is nearing the completion. Once successfully implemented,
the Electronic Blocks will be extensively evaluated. This evaluation has been
designed to explore the extent to which electronic blocks allow children to explore
programming concepts as hypothesised in this paper.<component x="57.88" y="85.72"
width="236.86" height="146.96" page="1" page_width="612.0"
page_height="792.0"></component><component x="317.34" y="320.8" width="237.21"
height="238.88" page="1" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.02" name_ratio="0.2587800369685767" word_count="541" lateness="0.25"
reference_score="2.19">When computers were first introduced in early childhood
settings, there was a propensity for using the computer as a tool to reinforce
existing practices, facilitating activities such as reading, writing and mathematics.
This mechanistic style of computer use, still seen to some extent in schools, led
educators to ask whether or not computer-based activities offer anything that is
substantially different from what can be obtained in the classroom by other means
[13][3][14]. The answer for some has been for educational institutions to embrace
computer use that offers opportunities for children to explore the computers' unique
dynamic and programmable properties. From as early as 1980, with the groundbreaking
work of Papert [9], researchers recognised that computer programming as an
educational activity had great potential as a vehicle for the acquisition of useful
cognitive skills such as problem solving and reflective thinking. The research
outlined in this paper follows this school of thought. It is widely acknowledged that
while computers can have many functions within an early education setting, its power
as a tool for technology education lies in the programmable and dynamic properties
unique to it. It is these properties which make it different from other media with
which children interact. This type of computer exploration allows children to become
involved in technology in a way recommended by Raizen et al. [10]. Computer
programming requires children to use their intellectual resources while involved in
processes such as designing, producing and using, to create systems and structures.
Programming also provides the opportunity for children to become involved in s"eeing
and constructing in terms of new formal knowledge of how things are put together"
[7]. For over a decade researchers a MIT Media Laboratory have been studying the
richness of experiences that involve exploration of the dynamic and programmable
properties of a computer. The strong belief that children benefit greatly from
becoming creators, not just consumers, of computer activities, drives their research.
It is a philosophy embraced by the research discussed in this paper. Programming a
computer allows children to have an impact on the technology they are using, they
become the creators, and they are in control. Through learning to program a computer
children develop a much deeper relationship with, and consequently deeper
understanding of, the computer [12]. Unfortunately for young children, the ideas
about instructions and sequence, which form the core of programming, are not
necessarily simple. At a time when young children are only just acquiring the
rudiments of notational systems and are struggling with symbolisation in language
[13], it would be unreasonable to expect them to cope with the symbolic systems
required to successfully program a computer. In addition, programming languages are
artificial rather than natural languages and consequently, they have a different
epistemology that deals with the unfamiliar world of computer data structures and
algorithms [15]. This makes them even more difficult to learn. As an alternative to
the computer, Electronic Blocks are designed to provide preschool and early primary
school children with a resource that has the unique dynamic and programmable
properties of a computer minus its complexity. Electronic Blocks are the physical
embodiment of computer programming. They are naturally less complex to program than a
computer as they do not require a knowledge of complex symbolic systems.<component
x="317.44" y="88.0" width="237.1" height="181.4" page="1" page_width="612.0"
page_height="792.0"></component><component x="57.88" y="122.4" width="237.18"
height="595.39" page="2" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.07" name_ratio="0.3448275862068966" word_count="29" lateness="0.25"
reference_score="2.69">The Electronic Block programming interface incorporates two
sets of design criteria, those that ensure the age-appropriateness of the design and
those that capture the programmable elements of a computer.<component x="317.44"
y="634.79" width="237.24" height="43.4" page="2" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.05" name_ratio="0.20491803278688525" word_count="244" lateness="0.25"
reference_score="3.23">In order to meet principles of developmentally appropriate
practices that reflect current knowledge and beliefs about what constitutes high
quality, developmentally appropriate early childhood education, the design of
Electronic Blocks must ensure: 1. activities are open-ended and discovery-oriented,
allowing children to be actively involved in the learning process; 2. interaction
encourages child-initiated play; 3. experiences involve active manipulation and
transformation of real materials; 4. entry level knowledge and experience is kept to
a minimum; 5. provision is made for childrens' varied skill and ability levels; 6.
construction activities that involve design, creation and evaluation processes form
the basis of interactions. (based on Bredekamp and Copple [2]) Applying the
principles of developmentally appropriate practices, aims to ensure that the
Electronic Blocks are a developmentally appropriate resource for providing
programming experiences to children under the age of eight. In addition, in order to
create a programmable resource, electronic blocks have been designed using guidelines
outlined by Resnick [11]. These guidelines have formed the basis of the following
design criteria. Electronic Blocks need to: 7. be non-algorithmic - the path of
action is not fully specified in advance; 8. be complex - the total path is not
visible; 9. incorporate uncertainty - not everything that bears on the task at hand
is known; 10. allow users to find structure in apparent disorder; 11. yield multiple
solutions, each with costs and benefits. These 11 design criteria have formed the
platform on which the Electronic Blocks have been based.<component x="317.44"
y="161.64" width="237.04" height="434.48" page="2" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.06" name_ratio="0.22377622377622378" word_count="143" lateness="0.375"
reference_score="4.14">The Electronic Blocks have been designed so children can
connect them just as they would any other blocks. The blocks have been made by
placing electronics inside Lego TM Duplo Primo blocks. This ensures that the blocks
are easy to stack and connect. Electronic Blocks have inputs and outputs and when
connected, the output of one block controls the input of another. There are three
kinds of electronic blocks: sensor blocks, action blocks and logic blocks. Sensor
blocks detect light, touch and sound within the environment. Action blocks produce
some kind of output: a light block produces light, while a movement block is capable
of motion. The sensor blocks will provide the signals that make the action blocks
a"ct". Logic blocks have an intermediary role. Placed between a sensor block and an
action block they have the ability to alter the expected action.<component x="317.44"
y="89.87" width="236.79" height="31.88" page="2" page_width="612.0"
page_height="792.0"></component><component x="57.88" y="559.32" width="236.98"
height="160.65" page="3" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.06" name_ratio="0.19387755102040816" word_count="98" lateness="0.375"
reference_score="4.55">There are three Electronic Sensor Blocks: a seeing block, a
hearing block and a touch block. These blocks are capable of detecting light, sound
and touch, respectively. They are single connector blocks that have an input attached
to the upper connector and an output attached to the lower connector (see Figure 1).
The input is off unless it explicitly receives an on signal. The input and the sensor
are ORed together to produce the output. As a result when two or more sensor blocks
are stacked on an action block any sensor input will trigger the action
block.<component x="57.88" y="408.24" width="236.87" height="112.4" page="3"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.03" name_ratio="0.20833333333333334" word_count="96" lateness="0.375"
reference_score="3.66">Action blocks produce some kind of output. The light block
produces light, the sound block produce sound and the movement block is capable of
motion. All action blocks are double connector blocks (see Figure 1). They are
physically constrained by a base plate so that they cannot be placed on top of
another block and have to be positioned at the bottom of a block stack. The two upper
connectors may receive an input signal. Each action block works as an OR - the action
takes place if the block receives input from either upper connector.<component
x="57.88" y="257.04" width="237.32" height="112.52" page="3" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.04" name_ratio="0.24778761061946902" word_count="113" lateness="0.375"
reference_score="4.0">With the exception of the and block, these blocks are single
connector blocks with an input attached to the upper connector and an output attached
to the lower connector (see Figure 1). The input of the not, toggle, and delay blocks
is off unless an on signal is received. An on signal will produce an output relative
to the logic of the block. The and block, a double connector block, has two upper
connectors which may receive an input signal (see Figure 1). The block works as a
logical AND - it must receive an input from both connectors to produce an output. The
output signal produced is attached to both lower connectors.<component x="57.88"
y="82.92" width="236.91" height="135.44" page="3" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.02" year_ratio="0.0"
cap_ratio="0.0" name_ratio="0.2222222222222222" word_count="45" lateness="0.375"
reference_score="2.39">Children of all ages are capable of programming using the
electronic blocks. They have been designed to be used by children across the early
childhood spectrum - children under five who are not engaged in the formal education
process as well as school aged children.<component x="317.44" y="250.56"
width="236.94" height="55.04" page="3" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="9.94" font="Times-Bold" letter_ratio="0.09" year_ratio="0.0"
cap_ratio="0.11" name_ratio="0" word_count="9" lateness="0.375"
reference_score="6.37">4.1. Pre-schoolers Programming ~ simple constructions
producing simple behaviours<component x="317.44" y="213.49" width="224.82"
height="22.54" page="3" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.03" name_ratio="0.2537313432835821" word_count="67" lateness="0.5"
reference_score="4.21">their touch. These are examples of simple sensor-action
combinations. Given a set of three sensor blocks and three action blocks, there are a
total of nine such combinations. While young children are becoming used to the
functionality of Electronic Blocks it may be advantageous to limit interactions to
these simple input-output combinations. Logic blocks may be added when children
demonstrate confidence using the sensor and action blocks.<component x="57.88"
y="616.92" width="237.15" height="100.88" page="4" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.02" year_ratio="0.0"
cap_ratio="0.01" name_ratio="0.2857142857142857" word_count="154" lateness="0.5"
reference_score="3.31">The addition of logic blocks to the set of Electronic Blocks
opens up a wide variety of additional construction opportunities. Logic blocks
provide users with the capability to: only produce an action if two input signals are
&#x2022; received simultaneously, produce an action if a particular stimulus is not
&#x2022; received, add a time delay between the sensor input and the &#x2022; desired
action, and toggle the input so that in the first instance the &#x2022; stimulus from
the environment will t"urn the action on" and the second instance of the stimulus
will "turn the action off". A task that sees the introduction of a logic block is the
creation of a car that starts when you clap and stops when you clap again. A toggle
block placed between a hearing block and a movement block will achieve this result.
Logic blocks add to the complexity and variety of structures that may be
created.<component x="57.88" y="347.89" width="237.07" height="230.34" page="4"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.04" name_ratio="0.17647058823529413" word_count="102" lateness="0.5"
reference_score="4.67">A fascinating aspect of Electronic Blocks is their ability to
interact not only with the environment but also with each other. An example of two
Electronic Block structures interacting is the creation of a remote control car. By
creating one block stack which contains a touch block and a light block and another
stack which has a seeing block on top of a movement block, a child has effectively
created a remote control car. By pressing the touch block, the child triggers the
light. This light in turn is detected as an input by the seeing block which actives
the movement block.<component x="57.88" y="184.08" width="237.07" height="112.4"
page="4" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.07" name_ratio="0.2523364485981308" word_count="214" lateness="0.5"
reference_score="5.18">Programming is generally thought of in terms of code writing
and debugging - in essence consisting of a" series of written instructions that make
a computer accomplish a task" (Pea and Kurland, 1984 as cited in [8]). However, in
recent years, the changing nature of computer interfaces has lead people to question
this definition of programming. Given the development of direct TM manipulation
programming languages such as ToonTalk [6] and Cocoa [15], the acceptance of
l"anguageless" programming as a legitimate alternative for the purpose of teaching
programming is gaining momentum. In addition to w"riting code " programming is about
defining a problem and being able to generate effective programming approaches with
an awareness of the alternatives that are most appropriate. A programmer needs to
design a solution based on a hypothesis of how the problem will best be solved.
Developing a solution requires an evaluation of alternate strategies and careful
planning of the steps required to achieve this solution. Subsequent testing is
required to determine the strengths and weaknesses of the original hypothesis. These
are the skills that the Electronic Blocks programming environment aim to promote. In
analysing the extent to which Electronic Blocks can promote the development of such
programming skills the following hierarchy (developed by Oakley and McDougall [8])
has been used:<component x="57.88" y="86.99" width="236.82" height="43.4" page="4"
page_width="612.0" page_height="792.0"></component><component x="317.44" y="455.88"
width="237.09" height="261.92" page="4" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.02" year_ratio="0.0"
cap_ratio="0.07" name_ratio="0.2857142857142857" word_count="28" lateness="0.5"
reference_score="4.71">Each of these skills is examined with respect to how it can be
achieved more readily using Electronic Blocks than by the use of a traditional
programming language.<component x="317.44" y="327.96" width="236.94" height="32.0"
page="4" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.01" name_ratio="0.2033898305084746" word_count="354" lateness="0.625"
reference_score="4.95">The syntax of Electronic Blocks is very simple. In order to
produce some kind of behaviour children must 1. Include an action block in the block
stack. 2. Include a sensor block in the block stack. 3. Place the action block at the
bottom of a block stack. All action blocks are physically constrained by a base plate
ensuring that they cannot be placed on top of another block. Therefore, creating a
block stack to produce a behaviour is simple. All that is required is one sensor
block and one action block. A child can create a car that moves in a bright
environment by placing a seeing block on top of a movement block. By placing a touch
block on a light block a child has created a camera flash - the light flashes when
they hit the button. In order to use logic blocks successfully children need to
understand that: 1. Logic blocks alter the signal they receive from the blocks above
them. If they are at the top of a block stack they will not effect the operation of
that stack. 2. If two sensor blocks are placed on top of a logic block then the logic
block will perform the logic operation when either environmental condition is met. In
the example in Figure 2 the light will turn on in the dark (ie. not light) or when
not touched. Either condition effects the behaviour of the action block. Logic blocks
increase the complexity of electronic block syntax. The order of placement of the
logic blocks within a program stack is an important consideration, as each change in
order has the potential to yield a different outcome. Fortunately, even with this
increase in complexity, two factors make it possible to work through logic issues
using trial and error. Firstly, any solution stack that has a sensor block and an
action block yields a testable behaviour. This allows the child to easily determine
the impact of a logic block in a stack. Secondly, changing a program stack is a
relatively straightforward operation - simply pulling the blocks apart and reordering
the stack.<component x="317.44" y="107.88" width="236.72" height="181.4" page="4"
page_width="612.0" page_height="792.0"></component><component x="57.88" y="467.4"
width="237.03" height="250.75" page="5" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.02" year_ratio="0.0"
cap_ratio="0.03" name_ratio="0.2903225806451613" word_count="62" lateness="0.625"
reference_score="4.76">Compared with the syntax of even the simplest computer
programming language, the syntax of electronic blocks are significantly less complex.
This lack of complexity ensures that Electronic Blocks provide a powerful platform
for teaching children fundamental programming concepts. Reducing the complexity of
the syntax provides children with greater opportunities to focus on high-level
programming concepts such as debugging, planning and evaluating strategies.<component
x="57.88" y="130.56" width="237.1" height="100.88" page="5" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.01" name_ratio="0.2413793103448276" word_count="348" lateness="0.625"
reference_score="4.58">An important issue in learning to program is program design -
successful mapping between problem domain and program domain (as defined by Brooks
cited in [4]). Research indicates that end user programmers have difficulty dealing
with entities in the program domain that do not have corresponding entities in the
problem domain and an abundance of low level primitives is one of the great cognitive
barriers to programming (for a review of this research see [4]). Given the cognitive
limitations of young children, it may be concluded that such difficulties would be
amplified. An important consideration, then, for creating a programming environment
for young children, is the inclusion of entities that map directly back to the
problem domain. Electronic blocks represent such entities. If a child wishes to
create a robot that sings in the light, then it is a simple matter of mapping the
problem to the blocks available. That child will need to include a seeing block so
the robot can tell whether it is light or dark and a noise block to create the sound.
If that child then wanted to create a robot that does not sing in the light it is a
matter of adding a not block to the program stack. If the child wants the robot to
sing in the light after a delay they just need to add a delay block. This
task-oriented style of programming makes the coding of simple structures relatively
simple. Each entity in the Electronic Block system maps directly to the problem
domain. While new task-specific visual programming languages are being designed to
address this issue, most computer programming languages are full of low-level
primitives that do not map directly back to the problem domain. The act of coding a
simple structure in most programming languages requires a knowledge of low-level
primitives and how they should be combined to achieve the desired result. Given that
young children rely more on their visual and auditory perception for knowledge than
they do on logical thought processes [5] it is understandable that they find type of
programming is extremely difficult.<component x="317.44" y="247.2" width="237.25"
height="446.0" page="5" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.04" name_ratio="0.1523809523809524" word_count="105" lateness="0.625"
reference_score="5.87">A child can create a camera flash by placing a touch block on
top of a light block. They can create a remote control car by placing a seeing block
on a movement block and then using the camera flash as the remote control (see Figure
3). Pressing the touch sensor would result in a light turning on. This light would be
sensed by the seeing block, which would in turn trigger the movement of the movement
block. A remote control vehicle has been created. This is an example of a way in
which Electronic Blocks allow children to reuse simple c"ode structures." The
same<component x="317.44" y="84.6" width="237.25" height="123.92" page="5"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.14" year_ratio="0.0"
cap_ratio="0.5" name_ratio="0" word_count="2" lateness="0.75"
reference_score="18.17">Movement Block<component x="110.2" y="500.87" width="43.21"
height="20.48" page="6" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.18" year_ratio="0.0"
cap_ratio="0.5" name_ratio="0" word_count="2" lateness="0.75"
reference_score="19.26">Light Block<component x="225.16" y="494.15" width="23.94"
height="20.72" page="6" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.05" name_ratio="0.23711340206185566" word_count="194" lateness="0.75"
reference_score="6.8">A programmer must plan the overall strategy for solving a
problem, break this strategy down into manageable units, and to systematically seek
out weakness in ones' reasoning. The Electronic Block programming environment
provides the opportunity for children to become involved in this type of planning
activity. To illustrate this point, the example of creating robots that wink at each
other is used. Initially a child might create two program stacks, each containing a
seeing block and a light block. The light block represents the "wink". This solution
has a problem. Neither robot will initiate the winking sequence. Both are sitting
waiting for a light input. The solution may involve the addition of a not block to
one of the stacks. This modification to Robot1 will result in it starting the winking
sequence. When Robot2 winks in response, Robot1 will sense the presence of the light
and its light will turn off. As a result Robot2s' light will then turn off. This
results in a wink by Robot1, and the process is repeated. This solution might be
further improved by the addition of a delay block to Robot2. This solution is
illustrated in Figure 4.<component x="317.44" y="316.2" width="237.1" height="250.52"
page="6" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.01" name_ratio="0.2" word_count="140" lateness="0.875"
reference_score="6.82">The emergent nature of the problem makes it an ideal
programming task for children. The path of action is not fully specified in advance,
nor is it visible. Children are required to make a plan of action, evaluate each step
through testing their solution and make any necessary adjustments. Possessing
strategies for planning and debugging is a prerequisite for programming success. Many
bugs arise as a result of plan composition problems - difficulties in putting the
p'ieces ' of a program together [4]. Electronic Blocks avoid this difficulty because
each piece of a program works independently and each step towards a solution may
easily be tested. In addition, research suggests that using spatial reasoning for
support may be useful in the planning and debugging processes [4]. Electronic Blocks
provide more scope for visual and spatial reasoning than text based
languages.<component x="57.88" y="524.88" width="237.24" height="192.92" page="7"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.05" name_ratio="0.25190839694656486" word_count="131" lateness="0.875"
reference_score="7.14">There are many Electronic Block programming tasks that have
multiple solutions, each with costs and benefits. As a physically embodied
programming environment, Electronic Blocks provide a powerful means for evaluating
alternate strategies. Children, unsure of the best solution, may easily build two
solutions concurrently, and then compare and contrast them. While young children
might struggle to logically analyse the positives and negatives of alternative
strategies (as may be required with a traditional programming language), their
natural curiosity and inherent desire to construct their own understanding of the
world, acts as a driving force in the exploration of such alternatives with
Electronic Blocks. Children are true scientific explorers of their environment and
within a nonthreatening environment that encourages autonomy, children will naturally
seek alternate strategies and test the limits of their creations.<component x="57.88"
y="293.28" width="237.24" height="192.92" page="7" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.06" name_ratio="0.2653061224489796" word_count="49" lateness="0.875"
reference_score="7.33">Electronic Blocks are physically embodied and consequently
will provide experiences that involve active manipulation and transformational of
real materials. The Electronic Blocks are undeniably a resource that allows children
to work both autonomously and actively, and the variety of expressive opportunities
they offer guarantees open-ended, discovery oriented learning experiences.<component
x="57.88" y="175.44" width="236.89" height="77.96" page="7" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.08" name_ratio="0.2619047619047619" word_count="126" lateness="0.875"
reference_score="7.78">The examples of programming outlined above show that children
can use the Electronic Block programming environment independently to build programs.
The theory of developmentally appropriate practice utilised in the design of the
electronic blocks guarantees a learning environment where children can experience
programming unimpeded. Alan Kay of the Apple Research Laboratory identified this as
of key significance. O"ne of the things I have been interested in for many years
&#x2026; is the possibility of giving young kids direct access to interesting ideas
via an interface that does not require the mediation of adults at all." [7] The
Electronic Block programming interface is simple to master and while things might not
always go to plan, making adjustments is as easy as pulling blocks apart and
rebuilding them.<component x="57.88" y="81.84" width="237.05" height="54.92" page="7"
page_width="612.0" page_height="792.0"></component><component x="317.44" y="570.84"
width="236.99" height="146.96" page="7" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.06" name_ratio="0.26666666666666666" word_count="135" lateness="0.875"
reference_score="7.44">In designing the Electronic Blocks consideration has been
given to providing a number of levels at which children can work. They can be used as
"normal" building blocks or provide challenges through the use of logic blocks and
through the creation of structures that interact. The flexibility - with respect to
skill and ability levels with which the Electronic Blocks have been designed, makes
them a powerful resource for teaching programming concepts. However, it is the more
complex interactions with Electronic Blocks, the use of logic blocks and interacting
block structures, which provide the greatest opportunities to learn about
programming. Examples outlined throughout the paper, demonstrate how the simplicity
of Electronic Block syntax allows for significant opportunities to explore
programming concepts such as defining a problem, planning the solution, testing and
debugging, and evaluating alternatives.<component x="317.44" y="326.64"
width="237.12" height="192.92" page="7" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.96" font="Times-Roman" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.06" name_ratio="0.2857142857142857" word_count="70" lateness="0.875"
reference_score="7.17">Theoretical evidence points to the Electronic Blocks being a
powerful tool for young children to experience programming without the use of a
computer. The next step in this project is to carry out evaluations in school
settings to the test this hypothesis. The Electronic Blocks are currently being
implemented following the design outlined in this paper. They will be taken into both
preschool and primary school settings for complete evaluation.<component x="317.44"
y="185.76" width="237.07" height="89.48" page="7" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.1" font="Times-Roman" letter_ratio="0.23" year_ratio="0.04"
cap_ratio="0.42" name_ratio="0.125" word_count="376" lateness="1.0"
reference_score="29.13">[1] Adams, T. (1996). Logo environments: The evolution of the
language. In J. Oakley (ed.), Logo in Australia: Selected readings (pp. 1-16).
Richmond, Vic: Computing in Education Group of Victoria. [2] Bredekamp, S., &amp;
Copple, C. (Eds.). (1997). Developmentally appropriate practice in early childhood
education. (Revised ed.). Washington, D.C.: National Association for the Education of
Young Children. [3] Cuffaro, H. K. (1984). Microcomputers in education: Why is
earlier better? Teachers College Record, 85, 559-568. [4] Green, T. R. G., &amp;
Petre, M. (1996). Usability analysis of visual programming environments: A 'cognitive
dimensions' framework. Journal of Visual Languages and Computing, 7, 131174. [5]
Gullo, D. F. (1992). Development and characteristics of kindergarten-age children. In
L. R. Williams, &amp; D. P. Fromberg (eds.), Encyclopaedia of early childhood
education (pp 206-207). New York: Garland Publishing Inc. TM - An animated
programming [6] Kahn, K. (1996). ToonTalk environment for children. Journal of Visual
Languages and Computing, 7, 197-217. [7] Kay, A. (1994). Observations about children
and computers. Advanced Technology Group, Learning Concepts Group, Apple Research
Laboratory Research Note No. 31. [Online]. Available:
http://www.atg.apple.com/technology/reports/RN31.html [8] Oakley, J., &amp;
McDougall, A. (1997). Young children as programmers: Fantasy or flight. In A.
McDougall, &amp; C. Dowling (Eds.), Learning in Logo microworlds. Richmond, Vic:
Computing in Education Group of Victoria. [9] Papert, S. (1980). Mindstorms:
Children, computers and powerful ideas. New York: Basic Books. [10] Raizen, S. A.,
Sellwood, P., Todd, R. D., &amp; Vickers, M. (1995). Technology education in the
classroom: Understanding the designed world. San Francisco: Jossey-Bass Publishers.
[11] Resnick, L. (1987). Education and learning to think. Committee on Mathematics,
Science, and Technology Education, Commission on Behavioural and Social Sciences and
Education, National Research Council. Washington, D.C.: National Academy Press. [12]
Resnick, M., Bruckman, A., &amp; Martin, F. (1996) Pianos not stereos: Creating
computational construction kits. Interactions, 3 (5), 41-50. [13] Sheingold, K.
(1987). The microcomputer as a symbolic medium. In R. D. Pea, &amp; K. Sheingold
(Eds.), Mirrors of minds: Patterns of experience in educational computing (pp
198-208). Norwood, NJ: Ablex Publishing Corporation. [14] Sloan, D. (1984). On
raising critical questions about the computer in education. Teachers College Record,
85, 539-547. [15] Smith, D. C., Cypher, A., &amp; Schmucker, K. (1996). Making
programming easier for children. Interactions, September - October, 59-67.<component
x="317.44" y="86.26" width="236.78" height="59.82" page="7" page_width="612.0"
page_height="792.0"></component><component x="57.88" y="254.48" width="237.39"
height="463.51" page="8" page_width="612.0"
page_height="792.0"></component></section>
  <reference order="1">Adams, T. (1996). Logo environments: The evolution of the
language. In J. Oakley (ed.), Logo in Australia: Selected readings (pp. 1-16).
Richmond, Vic: Computing in Education Group of Victoria.</reference>
  <reference order="2">Bredekamp, S., &amp; Copple, C. (Eds.). (1997).
Developmentally appropriate practice in early childhood education. (Revised ed.).
Washington, D.C.: National Association for the Education of Young
Children.</reference>
  <reference order="3">Cuffaro, H. K. (1984). Microcomputers in education: Why is
earlier better? Teachers College Record, 85, 559-568.</reference>
  <reference order="4">Green, T. R. G., &amp; Petre, M. (1996). Usability analysis of
visual programming environments: A 'cognitive dimensions' framework. Journal of
Visual Languages and Computing, 7, 131174.</reference>
  <reference order="5">Gullo, D. F. (1992). Development and characteristics of
kindergarten-age children. In L. R. Williams, &amp; D. P. Fromberg (eds.),
Encyclopaedia of early childhood education (pp 206-207). New York: Garland Publishing
Inc. TM - An animated programming</reference>
  <reference order="6">Kahn, K. (1996). ToonTalk environment for children. Journal of
Visual Languages and Computing, 7, 197-217.</reference>
  <reference order="7">Kay, A. (1994). Observations about children and computers.
Advanced Technology Group, Learning Concepts Group, Apple Research Laboratory
Research Note No. 31. [Online]. Available:
http://www.atg.apple.com/technology/reports/RN31.html</reference>
  <reference order="8">Oakley, J., &amp; McDougall, A. (1997). Young children as
programmers: Fantasy or flight. In A. McDougall, &amp; C. Dowling (Eds.), Learning in
Logo microworlds. Richmond, Vic: Computing in Education Group of
Victoria.</reference>
  <reference order="9">Papert, S. (1980). Mindstorms: Children, computers and
powerful ideas. New York: Basic Books.</reference>
  <reference order="10">Raizen, S. A., Sellwood, P., Todd, R. D., &amp; Vickers, M.
(1995). Technology education in the classroom: Understanding the designed world. San
Francisco: Jossey-Bass Publishers.</reference>
  <reference order="11">Resnick, L. (1987). Education and learning to think.
Committee on Mathematics, Science, and Technology Education, Commission on
Behavioural and Social Sciences and Education, National Research Council. Washington,
D.C.: National Academy Press.</reference>
  <reference order="12">Resnick, M., Bruckman, A., &amp; Martin, F. (1996) Pianos not
stereos: Creating computational construction kits. Interactions, 3 (5),
41-50.</reference>
  <reference order="13">Sheingold, K. (1987). The microcomputer as a symbolic medium.
In R. D. Pea, &amp; K. Sheingold (Eds.), Mirrors of minds: Patterns of experience in
educational computing (pp 198-208). Norwood, NJ: Ablex Publishing
Corporation.</reference>
  <reference order="14">Sloan, D. (1984). On raising critical questions about the
computer in education. Teachers College Record, 85, 539-547.</reference>
  <reference order="15">Smith, D. C., Cypher, A., &amp; Schmucker, K. (1996). Making
programming easier for children. Interactions, September - October,
59-67.</reference>
  <reference order="1">Adams, T. (1996). Logo environments: The evolution of the
language. In J. Oakley (ed.), Logo in Australia: Selected readings (pp. 1-16).
Richmond, Vic: Computing in Education Group of Victoria.</reference>
  <reference order="2">Bredekamp, S., &amp; Copple, C. (Eds.). (1997).
Developmentally appropriate practice in early childhood education. (Revised ed.).
Washington, D.C.: National Association for the Education of Young
Children.</reference>
  <reference order="3">Cuffaro, H. K. (1984). Microcomputers in education: Why is
earlier better? Teachers College Record, 85, 559-568.</reference>
  <reference order="4">Green, T. R. G., &amp; Petre, M. (1996). Usability analysis of
visual programming environments: A 'cognitive dimensions' framework. Journal of
Visual Languages and Computing, 7, 131174.</reference>
  <reference order="5">Gullo, D. F. (1992). Development and characteristics of
kindergarten-age children. In L. R. Williams, &amp; D. P. Fromberg (eds.),
Encyclopaedia of early childhood education (pp 206-207). New York: Garland Publishing
Inc. TM - An animated programming</reference>
  <reference order="6">Kahn, K. (1996). ToonTalk environment for children. Journal of
Visual Languages and Computing, 7, 197-217.</reference>
  <reference order="7">Kay, A. (1994). Observations about children and computers.
Advanced Technology Group, Learning Concepts Group, Apple Research Laboratory
Research Note No. 31. [Online]. Available:
http://www.atg.apple.com/technology/reports/RN31.html</reference>
  <reference order="8">Oakley, J., &amp; McDougall, A. (1997). Young children as
programmers: Fantasy or flight. In A. McDougall, &amp; C. Dowling (Eds.), Learning in
Logo microworlds. Richmond, Vic: Computing in Education Group of
Victoria.</reference>
  <reference order="9">Papert, S. (1980). Mindstorms: Children, computers and
powerful ideas. New York: Basic Books.</reference>
  <reference order="10">Raizen, S. A., Sellwood, P., Todd, R. D., &amp; Vickers, M.
(1995). Technology education in the classroom: Understanding the designed world. San
Francisco: Jossey-Bass Publishers.</reference>
  <reference order="11">Resnick, L. (1987). Education and learning to think.
Committee on Mathematics, Science, and Technology Education, Commission on
Behavioural and Social Sciences and Education, National Research Council. Washington,
D.C.: National Academy Press.</reference>
  <reference order="12">Resnick, M., Bruckman, A., &amp; Martin, F. (1996) Pianos not
stereos: Creating computational construction kits. Interactions, 3 (5),
41-50.</reference>
  <reference order="13">Sheingold, K. (1987). The microcomputer as a symbolic medium.
In R. D. Pea, &amp; K. Sheingold (Eds.), Mirrors of minds: Patterns of experience in
educational computing (pp 198-208). Norwood, NJ: Ablex Publishing
Corporation.</reference>
  <reference order="14">Sloan, D. (1984). On raising critical questions about the
computer in education. Teachers College Record, 85, 539-547.</reference>
  <reference order="15">Smith, D. C., Cypher, A., &amp; Schmucker, K. (1996). Making
programming easier for children. Interactions, September - October,
59-67.</reference>
  <resolved_reference order="1">Adams, T. (1996). Logo environments: The evolution of
the language. In J. Oakley (ed.), Logo in Australia: Selected readings (pp. 1-16).
Richmond, Vic: Computing in Education Group of Victoria.</resolved_reference>
  <resolved_reference order="2">Bredekamp, S., &amp; Copple, C. (Eds.). (1997).
Developmentally appropriate practice in early childhood education. (Revised ed.).
Washington, D.C.: National Association for the Education of Young
Children.</resolved_reference>
  <resolved_reference order="3">Cuffaro, H. K. (1984). Microcomputers in education:
Why is earlier better? Teachers College Record, 85, 559-568.</resolved_reference>
  <resolved_reference order="4">Green, T. R. G., &amp; Petre, M. (1996). Usability
analysis of visual programming environments: A 'cognitive dimensions' framework.
Journal of Visual Languages and Computing, 7, 131174.</resolved_reference>
  <resolved_reference order="5">Gullo, D. F. (1992). Development and characteristics
of kindergarten-age children. In L. R. Williams, &amp; D. P. Fromberg (eds.),
Encyclopaedia of early childhood education (pp 206-207). New York: Garland Publishing
Inc. TM - An animated programming</resolved_reference>
  <resolved_reference order="6">Kahn, K. (1996). ToonTalk environment for children.
Journal of Visual Languages and Computing, 7, 197-217.</resolved_reference>
  <resolved_reference order="7">Kay, A. (1994). Observations about children and
computers. Advanced Technology Group, Learning Concepts Group, Apple Research
Laboratory Research Note No. 31. [Online]. Available:
http://www.atg.apple.com/technology/reports/RN31.html</resolved_reference>
  <resolved_reference order="8">Oakley, J., &amp; McDougall, A. (1997). Young
children as programmers: Fantasy or flight. In A. McDougall, &amp; C. Dowling (Eds.),
Learning in Logo microworlds. Richmond, Vic: Computing in Education Group of
Victoria.</resolved_reference>
  <resolved_reference order="9">Papert, S. (1980). Mindstorms: Children, computers
and powerful ideas. New York: Basic Books.</resolved_reference>
  <resolved_reference order="10">Raizen, S. A., Sellwood, P., Todd, R. D., &amp;
Vickers, M. (1995). Technology education in the classroom: Understanding the designed
world. San Francisco: Jossey-Bass Publishers.</resolved_reference>
  <resolved_reference order="11">Resnick, L. (1987). Education and learning to think.
Committee on Mathematics, Science, and Technology Education, Commission on
Behavioural and Social Sciences and Education, National Research Council. Washington,
D.C.: National Academy Press.</resolved_reference>
  <resolved_reference order="12">Resnick, M., Bruckman, A., &amp; Martin, F. (1996)
Pianos not stereos: Creating computational construction kits. Interactions, 3 (5),
41-50.</resolved_reference>
  <resolved_reference order="13">Sheingold, K. (1987). The microcomputer as a
symbolic medium. In R. D. Pea, &amp; K. Sheingold (Eds.), Mirrors of minds: Patterns
of experience in educational computing (pp 198-208). Norwood, NJ: Ablex Publishing
Corporation.</resolved_reference>
  <resolved_reference order="14">Sloan, D. (1984). On raising critical questions
about the computer in education. Teachers College Record, 85,
539-547.</resolved_reference>
  <resolved_reference order="15">Smith, D. C., Cypher, A., &amp; Schmucker, K.
(1996). Making programming easier for children. Interactions, September - October,
59-67.</resolved_reference>
  <page width="612" height="792" number="1">
    <header x="57.88" y="676.99" width="496.67" height="12.64"></header>
  </page>
</pdf>
