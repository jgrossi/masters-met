<?xml version="1.0"?>
<pdf>
  <title line_height="26.57" font="JEKBNJ+TimesNewRoman">A Joint Controller-Simulator
Programming by Demonstration Method for PLC Devices</title>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.07"
year_ratio="0.0" cap_ratio="0.26" name_ratio="0.18855218855218855" word_count="297"
lateness="0.16666666666666666" reference_score="8.83">NTRODUCTION I. I Programmable
Logic Controller (PLC) is a digitally operating electronic apparatus which uses a
programmable memory for the internal storage of instructions. It includes functions
such as logic sequencing, timing, counting, and arithmetic operations, to control
various types of machines or processes. PLCs programs are generally written by a
specialized programming language as specified by the IEC 1131-3 standard. It is thus
not possible for an end user to program the devices. Programming by demonstration
(PBD) concerns with providing a non-programmer tools and techniques to control,
automate, and customize the software applications or intelligent physical devices.
PBD technique is simpler than procedural programming because there is no need to
learn a language syntax and rules. This concept has been applied for various purposes
such as those listed below. &#x2022; &#x2022; Automation of repetitive tasks using
software functions. For example, a macro recorder learns patterns of user's activity
and can then execute those patterns autonomously. [1, 5] User interface customization
and personalization. Here, PBD is applied to change interface appearance to optimize
access to frequently used functions. [6] II. PROGRAMMING PARADIGMS FOR PLC DEVICES
Programming paradigm is a paradigmatic style of programming. It provides and
determines the view that the programmer has of the execution of the program. For
examples, in object-oriented programming, programmers can think of a program as a
collection of interacting objects, while in functional programming it can be thought
of as a sequence of stateless function evaluations. The common PLC programming
paradigms are described below. 1) Conventional programming paradigm: This is a
programming paradigm based upon the concept of procedures, also known as routines,
subroutines, methods, or functions, that contain a series of computational steps.
Examples of PLC languages under this conventional programming paradigm category are
mnemonic and ST (Structure text) language.<component x="44.64" y="106.55"
width="256.46" height="269.05" page="1" page_width="612.0"
page_height="792.0"></component><component x="315.12" y="138.46" width="257.19"
height="180.85" page="1" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.77" font="JEKBNJ+TimesNewRoman" letter_ratio="0.08"
year_ratio="0.0" cap_ratio="0.23" name_ratio="0.23076923076923078" word_count="13"
lateness="0.3333333333333333" reference_score="9.65">Figure 1. A block diagram of PLC
programming under the conventional programming paradigm<component x="51.84"
y="614.61" width="238.8" height="17.89" page="2" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.03"
year_ratio="0.0" cap_ratio="0.03" name_ratio="0.21666666666666667" word_count="60"
lateness="0.3333333333333333" reference_score="5.59">2) Visual programming paradigm:
This is a programming language that uses a visual representation such as graphics,
drawing, animation or icons, partially or completely. It views program construction
as a visual task similar to the solving of jigsaw puzzles. Example of the language
that uses this programming paradigm includes the ladder diagram, the function block,
and the sequential function chart.<component x="44.64" y="520.3" width="258.28"
height="83.16" page="2" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.05"
year_ratio="0.0" cap_ratio="0.12" name_ratio="0.21686746987951808" word_count="83"
lateness="0.3333333333333333" reference_score="7.23">Programming by Demonstrations
(PBD) is the most recent approach to programming and is largely used at present for
end-user programming. The essential notion is that the user demonstrates a program to
the system by working through one or more examples. The system then generalizes the
users' sequence of actions to produce a general program. One of the best known such
systems is Cypher's EAGER system which can automatically detect repetitions in user's
actions and build a program to perform the use task. [11]<component x="44.64"
y="233.03" width="256.35" height="98.52" page="2" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.77" font="JEKBNJ+TimesNewRoman" letter_ratio="0.06"
year_ratio="0.0" cap_ratio="0.0" name_ratio="0.18181818181818182" word_count="11"
lateness="0.3333333333333333" reference_score="5.9">Figure 3. A conceptual view of
the programming by demonstration paradigm<component x="44.88" y="96.93"
width="254.76" height="8.77" page="2" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.08"
year_ratio="0.0" cap_ratio="0.4" name_ratio="0.19574468085106383" word_count="235"
lateness="0.3333333333333333" reference_score="12.21">The programming by
demonstration paradigm is generally applicable only when the full functional system
(to be programmed) is available. Therefore, applicability of PBD to program a new
system that has not yet existed is questionable. Similarly, applying PBD concept to
PLC programming requires the existence of a controlled system to be interacted with
during the demonstration. In this paper, the above problem is solved by a joint
controller-simulator programming by demonstration method. This technique combines
visual programming and PBD for jointly programming of controller devices and a
simulation model of the controlled devices. A joint controller-simulator programming
by demonstration method is described in the next section. III. A JOINT
CONTROLLER-SIMULATOR PROGRAMMING BY DEMONSTRATION METHOD FOR PLC DEVICES A joint
controller-simulator programming by demonstration &#x2022; &#x2022; &#x2022; &#x2022;
method is composed of four parts as follows (see Figure 4): Model builder: This
module is responsible for building relationships among controller devices and
controlled system. System simulator: This module provides an animated display of the
controlled system dynamics in response to a controller action. User action recorder:
This module records a user action for the purpose of both programming the controlled
system simulation model and the controller. Compiler: This module is used to
transform a recorded user action into an actual PLC programming code. The code can be
in a high level language such as a structure text, or a low-level one such as a
mnemonic code.<component x="315.12" y="579.35" width="257.19" height="159.23"
page="2" page_width="612.0" page_height="792.0"></component><component x="315.12"
y="336.23" width="256.51" height="228.98" page="2" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.05"
year_ratio="0.0" cap_ratio="0.09" name_ratio="0.1624548736462094" word_count="277"
lateness="0.5" reference_score="9.14">Conceptually, the system as shown in Figure 4
operates in one of five modes (states) as explained below (see Figure 5). 1) System
initialization mode: In this mode, a controlled system is created by a user through
visual interface. Each controlled device and the corresponding properties can be
defined. In addition, through visual programming, general relationship among
controlled devices, and between controlled devices and the controller devices can be
declared (visually). 2) Simulator programming mode: Under this mode, a system
simulation model, which captures the relationship among controlling and controlled
devices, can be programmed through user demonstration. A user programs the model by
demonstrating how controlled device's properties change in response to a controller
action, as well as to changes in other controlled devices' properties. 3) Controller
programming mode: In this mode, a user is allowed to define a controller action in
response to a particular system state. As for the case of the simulator programming
mode, a controller is programmed through user demonstration of actions. 4) Simulation
mode: In this mode, a programming tool demonstrates to a user how a system state
changes in response to a controller action and vice versa. The simulation is provided
based on a system simulation model, constructed from previous user actions under Mode
2. Therefore, the model may be incomplete and the simulation may be inaccurate.
System model and simulation accuracy can be corrected, however, through iteratively
re-programming. 5) Compiler mode: When in this mode, the tool transforms user actions
into an actual PLC programming code. For example, the tool developed in this study
chooses ST (Structure Text) as specified by the IEC1131-3 standard as a targeted PLC
programming language.<component x="315.12" y="91.66" width="256.95" height="76.2"
page="2" page_width="612.0" page_height="792.0"></component><component x="44.64"
y="414.22" width="257.2" height="323.16" page="3" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.1"
year_ratio="0.0" cap_ratio="0.38" name_ratio="0.18518518518518517" word_count="81"
lateness="0.5" reference_score="13.85">IV. PBD-BASED PLC PROGRAMMING TOOL In this
section, design of the tool developed based on the proposed method as described in
Section 3 is described below. 1) Model builder: This module is active when the tool
is in the system initialization mode. It is used for system model construction. Using
a visual programming paradigm, a controlled and/or controller device is defined by
the selection of icons from the tool palette. Each device's properties are defined
through the object inspector (see Figure6).<component x="44.64" y="168.46"
width="257.18" height="115.32" page="3" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.77" font="JEKBNJ+TimesNewRoman" letter_ratio="0.31"
year_ratio="0.0" cap_ratio="0.5" name_ratio="0" word_count="12" lateness="0.5"
reference_score="16.43">TABLE I. Device 1. Activator 2.Sensor 3.Container 4.Counter
5.Timer 6.Generic 7. PipeLine<component x="326.64" y="395.97" width="49.38"
height="136.93" page="3" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.77" font="JEKBNJ+TimesNewRoman" letter_ratio="0.17"
year_ratio="0.0" cap_ratio="1.21" name_ratio="0.05128205128205128" word_count="39"
lateness="0.5" reference_score="7.43">TANDARD OBJECT CLASSES SUPPORTED BY THE TOOLS
Description A generic controller's output device A generic controller's input device
A generic controlled device A specialized counter device A specialized timer device A
general purpose device class for extension A Connector<component x="380.64"
y="395.97" width="175.32" height="136.93" page="3" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.77" font="JEKBNJ+TimesNewRoman" letter_ratio="0.09"
year_ratio="0.0" cap_ratio="0.1" name_ratio="0.26666666666666666" word_count="30"
lateness="0.8333333333333334" reference_score="11.76">Figure 10. Using the tool to
program the system model when Pump1 is turned on Figure 11. Using the tool to program
the system model when Valve1 is turned on<component x="315.12" y="98.85"
width="252.04" height="17.89" page="4" page_width="612.0"
page_height="792.0"></component><component x="45.36" y="301.17" width="250.38"
height="17.89" page="5" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.05"
year_ratio="0.0" cap_ratio="0.07" name_ratio="0.21686746987951808" word_count="166"
lateness="0.8333333333333334" reference_score="10.34">3) Controller Porgramming: To
illustrate how to program a controller through demonstration, consider the following
scenarios. a) While in a simulation mode, a user notices that a water level is
increasing. Once the level arrives at the point specified by Sensor 1, the simulator
then prompts a user for a controller action by switching to a controller programming
mode. The user informs the tool to continue the simulation. When the level arrives at
the point specified by Sensor 2, the simulator prompts for the action again. This
time, however, the user defines the action by visually turning Pump1 off. The tool
then records that action (and if no other action, the tool switches to the simulator
programming mode). b) While in a simulation mode, the water level is decreasing. When
it passes the level below that specified by Sensor1, a user can proactively turns the
tool into a controller programming mode himself. He then can program the controller
by visually turning Pump1 on (see Figure 12).<component x="44.64" y="76.3"
width="256.56" height="213.86" page="5" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.77" font="JEKBNJ+TimesNewRoman" letter_ratio="0.06"
year_ratio="0.0" cap_ratio="0.0" name_ratio="0.3" word_count="10"
lateness="0.8333333333333334" reference_score="9.53">Figure 12. Programming the
controller during the controller programming mode<component x="322.08" y="258.93"
width="238.88" height="17.89" page="5" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.05"
year_ratio="0.0" cap_ratio="0.0" name_ratio="0.4074074074074074" word_count="27"
lateness="0.8333333333333334" reference_score="8.52">Figure 13 describes the sequence
of user actions to program both the simulator and the controller. From the figure,
note the iterative nature of the joint-programming process.<component x="315.12"
y="215.98" width="256.34" height="33.0" page="5" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.08"
year_ratio="0.0" cap_ratio="0.33" name_ratio="0.09523809523809523" word_count="21"
lateness="1.0" reference_score="15.59">From the changes in controller devices' states
as described, those involved devices' states can be summarized as shown in TABLE
II.<component x="44.64" y="539.26" width="256.94" height="33.0" page="6"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.04"
year_ratio="0.0" cap_ratio="0.09" name_ratio="0.17647058823529413" word_count="85"
lateness="1.0" reference_score="11.26">From the above state table, a truth table
describing all possible logic combinations of the controller devices' states can be
derived as shown in TABLE III. In this case, user action scenarios cover all possible
combinations. Therefore, the truth table is simply the state table with redundant row
being removed. When user action scenarios do not cover all possible combinations, the
tool must ask the user for more information by displaying the missing scenarios. The
topic of generating a missing scenario is discussed elsewhere, however.<component
x="44.64" y="290.87" width="258.33" height="98.76" page="6" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.77" font="JEKBNJ+TimesNewRoman" letter_ratio="0.26"
year_ratio="0.0" cap_ratio="1.21" name_ratio="0.16346153846153846" word_count="312"
lateness="1.0" reference_score="11.67">ODES GENERATED ORRESPONDING O ISITED CENARIOS
TABLE IV. C C T V S Scenario Sensor Sensor1; Sensor Sensor2; Activator Pump1;
IF(Sensor1.State = Off &amp; Sensor2.State = Off) Pump1.State = On; Sensor2.State =
On) Pump1.State = Off; IF(Sensor1.State = On &amp; A U DND SER EMONSTRATIONS ST
generated code INPUT_VAR Sensor1:BOOL; Sensor2:BOOL; END_VAR OUTPUT_VAR Pump1:BOOL;
END_VAR IF Sensor FALSE AND Sensor 1 = 2 = FALSE THEN Pump TRUE; 1 := END_IF; IF
Sensor1 = TRUE AND Sensor2 = TRUE THEN Pump1 :=FALSE; END_IF; REFERENCES [1] Gordon
W. Paynter and Ian H. Witten, "Applying machine learning to programming by
demonstration", University of California, Riverside and University of Waikato New
Zealand, 2004. [2] Haiying She and Axel Graeser, "Closed Loop Control and Automatic
Set Point Generation in Programming by Demonstration for Service Robotic Tasks",
University of Bremen, Germany, 2004. [3] Richard M. Voyles, "Toward Gesture-Based
Programming: AgentBased Haptic Skill Acquisition and Interpretation", University of
Minnesota, 1997. [4] S. Munch, J. Kreuziger, M. Kaiser, R. Dillmann , "Robot
Programming by Demonstration (RPD) Using Machine Learning and User Interaction
Methods for the Development of Easy and Comfortable Robot Programming System",
University of Karlsruhe, Germany, 1994. [5] Tessa Lau, "Programming by Demonstration:
a Machine Learning Approach", University of Washington, 2001. [6] Lawrence D.Bergman,
Tessa A. Lau, Vittrio Castelli, Daniel Oblinger, "Programming-by-Demonstration for
Behavior-based User Interface Customization", IBM T.J. Watson research Center, USA,
2004. [7] Henry Lieberman, "Your Wish is My Command: Giving Users the Power to
Instruct their Software", Massachusetts Institute of Technology, 2000. [8] Richard G.
McDaniel, "Creating Complete User Interfaces by Demonstration", Carnegie Mellon
University, 1993. [9] Ben Shneiderman, "Foreword to Your Wish is My Command",
University of Maryland, 2000. [10] Karl-Heinz john and Michael Tiegelkamp, "ICE
61131-3 Programming Industrial Automation Systems", Springer, january 2001. [11]
Cypher, Allen, Introduction, In Cypher, Allen, ed., "Watch What I Do: Programming by
Demonstration", Cambridge: The MIT Press, 1993.<component x="315.36" y="550.77"
width="253.14" height="158.77" page="6" page_width="612.0"
page_height="792.0"></component><component x="315.12" y="89.49" width="255.41"
height="301.57" page="6" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.07"
year_ratio="0.0" cap_ratio="0.26" name_ratio="0.18855218855218855" word_count="297"
lateness="0.16666666666666666" reference_score="8.83">NTRODUCTION I. I Programmable
Logic Controller (PLC) is a digitally operating electronic apparatus which uses a
programmable memory for the internal storage of instructions. It includes functions
such as logic sequencing, timing, counting, and arithmetic operations, to control
various types of machines or processes. PLCs programs are generally written by a
specialized programming language as specified by the IEC 1131-3 standard. It is thus
not possible for an end user to program the devices. Programming by demonstration
(PBD) concerns with providing a non-programmer tools and techniques to control,
automate, and customize the software applications or intelligent physical devices.
PBD technique is simpler than procedural programming because there is no need to
learn a language syntax and rules. This concept has been applied for various purposes
such as those listed below. &#x2022; &#x2022; Automation of repetitive tasks using
software functions. For example, a macro recorder learns patterns of user's activity
and can then execute those patterns autonomously. [1, 5] User interface customization
and personalization. Here, PBD is applied to change interface appearance to optimize
access to frequently used functions. [6] II. PROGRAMMING PARADIGMS FOR PLC DEVICES
Programming paradigm is a paradigmatic style of programming. It provides and
determines the view that the programmer has of the execution of the program. For
examples, in object-oriented programming, programmers can think of a program as a
collection of interacting objects, while in functional programming it can be thought
of as a sequence of stateless function evaluations. The common PLC programming
paradigms are described below. 1) Conventional programming paradigm: This is a
programming paradigm based upon the concept of procedures, also known as routines,
subroutines, methods, or functions, that contain a series of computational steps.
Examples of PLC languages under this conventional programming paradigm category are
mnemonic and ST (Structure text) language.<component x="44.64" y="106.55"
width="256.46" height="269.05" page="1" page_width="612.0"
page_height="792.0"></component><component x="315.12" y="138.46" width="257.19"
height="180.85" page="1" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.77" font="JEKBNJ+TimesNewRoman" letter_ratio="0.08"
year_ratio="0.0" cap_ratio="0.23" name_ratio="0.23076923076923078" word_count="13"
lateness="0.3333333333333333" reference_score="9.65">Figure 1. A block diagram of PLC
programming under the conventional programming paradigm<component x="51.84"
y="614.61" width="238.8" height="17.89" page="2" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.03"
year_ratio="0.0" cap_ratio="0.03" name_ratio="0.21666666666666667" word_count="60"
lateness="0.3333333333333333" reference_score="5.59">2) Visual programming paradigm:
This is a programming language that uses a visual representation such as graphics,
drawing, animation or icons, partially or completely. It views program construction
as a visual task similar to the solving of jigsaw puzzles. Example of the language
that uses this programming paradigm includes the ladder diagram, the function block,
and the sequential function chart.<component x="44.64" y="520.3" width="258.28"
height="83.16" page="2" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.05"
year_ratio="0.0" cap_ratio="0.12" name_ratio="0.21686746987951808" word_count="83"
lateness="0.3333333333333333" reference_score="7.23">Programming by Demonstrations
(PBD) is the most recent approach to programming and is largely used at present for
end-user programming. The essential notion is that the user demonstrates a program to
the system by working through one or more examples. The system then generalizes the
users' sequence of actions to produce a general program. One of the best known such
systems is Cypher's EAGER system which can automatically detect repetitions in user's
actions and build a program to perform the use task. [11]<component x="44.64"
y="233.03" width="256.35" height="98.52" page="2" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.77" font="JEKBNJ+TimesNewRoman" letter_ratio="0.06"
year_ratio="0.0" cap_ratio="0.0" name_ratio="0.18181818181818182" word_count="11"
lateness="0.3333333333333333" reference_score="5.9">Figure 3. A conceptual view of
the programming by demonstration paradigm<component x="44.88" y="96.93"
width="254.76" height="8.77" page="2" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.08"
year_ratio="0.0" cap_ratio="0.4" name_ratio="0.19574468085106383" word_count="235"
lateness="0.3333333333333333" reference_score="12.21">The programming by
demonstration paradigm is generally applicable only when the full functional system
(to be programmed) is available. Therefore, applicability of PBD to program a new
system that has not yet existed is questionable. Similarly, applying PBD concept to
PLC programming requires the existence of a controlled system to be interacted with
during the demonstration. In this paper, the above problem is solved by a joint
controller-simulator programming by demonstration method. This technique combines
visual programming and PBD for jointly programming of controller devices and a
simulation model of the controlled devices. A joint controller-simulator programming
by demonstration method is described in the next section. III. A JOINT
CONTROLLER-SIMULATOR PROGRAMMING BY DEMONSTRATION METHOD FOR PLC DEVICES A joint
controller-simulator programming by demonstration &#x2022; &#x2022; &#x2022; &#x2022;
method is composed of four parts as follows (see Figure 4): Model builder: This
module is responsible for building relationships among controller devices and
controlled system. System simulator: This module provides an animated display of the
controlled system dynamics in response to a controller action. User action recorder:
This module records a user action for the purpose of both programming the controlled
system simulation model and the controller. Compiler: This module is used to
transform a recorded user action into an actual PLC programming code. The code can be
in a high level language such as a structure text, or a low-level one such as a
mnemonic code.<component x="315.12" y="579.35" width="257.19" height="159.23"
page="2" page_width="612.0" page_height="792.0"></component><component x="315.12"
y="336.23" width="256.51" height="228.98" page="2" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.05"
year_ratio="0.0" cap_ratio="0.09" name_ratio="0.1624548736462094" word_count="277"
lateness="0.5" reference_score="9.14">Conceptually, the system as shown in Figure 4
operates in one of five modes (states) as explained below (see Figure 5). 1) System
initialization mode: In this mode, a controlled system is created by a user through
visual interface. Each controlled device and the corresponding properties can be
defined. In addition, through visual programming, general relationship among
controlled devices, and between controlled devices and the controller devices can be
declared (visually). 2) Simulator programming mode: Under this mode, a system
simulation model, which captures the relationship among controlling and controlled
devices, can be programmed through user demonstration. A user programs the model by
demonstrating how controlled device's properties change in response to a controller
action, as well as to changes in other controlled devices' properties. 3) Controller
programming mode: In this mode, a user is allowed to define a controller action in
response to a particular system state. As for the case of the simulator programming
mode, a controller is programmed through user demonstration of actions. 4) Simulation
mode: In this mode, a programming tool demonstrates to a user how a system state
changes in response to a controller action and vice versa. The simulation is provided
based on a system simulation model, constructed from previous user actions under Mode
2. Therefore, the model may be incomplete and the simulation may be inaccurate.
System model and simulation accuracy can be corrected, however, through iteratively
re-programming. 5) Compiler mode: When in this mode, the tool transforms user actions
into an actual PLC programming code. For example, the tool developed in this study
chooses ST (Structure Text) as specified by the IEC1131-3 standard as a targeted PLC
programming language.<component x="315.12" y="91.66" width="256.95" height="76.2"
page="2" page_width="612.0" page_height="792.0"></component><component x="44.64"
y="414.22" width="257.2" height="323.16" page="3" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.1"
year_ratio="0.0" cap_ratio="0.38" name_ratio="0.18518518518518517" word_count="81"
lateness="0.5" reference_score="13.85">IV. PBD-BASED PLC PROGRAMMING TOOL In this
section, design of the tool developed based on the proposed method as described in
Section 3 is described below. 1) Model builder: This module is active when the tool
is in the system initialization mode. It is used for system model construction. Using
a visual programming paradigm, a controlled and/or controller device is defined by
the selection of icons from the tool palette. Each device's properties are defined
through the object inspector (see Figure6).<component x="44.64" y="168.46"
width="257.18" height="115.32" page="3" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.77" font="JEKBNJ+TimesNewRoman" letter_ratio="0.31"
year_ratio="0.0" cap_ratio="0.5" name_ratio="0" word_count="12" lateness="0.5"
reference_score="16.43">TABLE I. Device 1. Activator 2.Sensor 3.Container 4.Counter
5.Timer 6.Generic 7. PipeLine<component x="326.64" y="395.97" width="49.38"
height="136.93" page="3" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.77" font="JEKBNJ+TimesNewRoman" letter_ratio="0.17"
year_ratio="0.0" cap_ratio="1.21" name_ratio="0.05128205128205128" word_count="39"
lateness="0.5" reference_score="7.43">TANDARD OBJECT CLASSES SUPPORTED BY THE TOOLS
Description A generic controller's output device A generic controller's input device
A generic controlled device A specialized counter device A specialized timer device A
general purpose device class for extension A Connector<component x="380.64"
y="395.97" width="175.32" height="136.93" page="3" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.77" font="JEKBNJ+TimesNewRoman" letter_ratio="0.09"
year_ratio="0.0" cap_ratio="0.1" name_ratio="0.26666666666666666" word_count="30"
lateness="0.8333333333333334" reference_score="11.76">Figure 10. Using the tool to
program the system model when Pump1 is turned on Figure 11. Using the tool to program
the system model when Valve1 is turned on<component x="315.12" y="98.85"
width="252.04" height="17.89" page="4" page_width="612.0"
page_height="792.0"></component><component x="45.36" y="301.17" width="250.38"
height="17.89" page="5" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.05"
year_ratio="0.0" cap_ratio="0.07" name_ratio="0.21686746987951808" word_count="166"
lateness="0.8333333333333334" reference_score="10.34">3) Controller Porgramming: To
illustrate how to program a controller through demonstration, consider the following
scenarios. a) While in a simulation mode, a user notices that a water level is
increasing. Once the level arrives at the point specified by Sensor 1, the simulator
then prompts a user for a controller action by switching to a controller programming
mode. The user informs the tool to continue the simulation. When the level arrives at
the point specified by Sensor 2, the simulator prompts for the action again. This
time, however, the user defines the action by visually turning Pump1 off. The tool
then records that action (and if no other action, the tool switches to the simulator
programming mode). b) While in a simulation mode, the water level is decreasing. When
it passes the level below that specified by Sensor1, a user can proactively turns the
tool into a controller programming mode himself. He then can program the controller
by visually turning Pump1 on (see Figure 12).<component x="44.64" y="76.3"
width="256.56" height="213.86" page="5" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.77" font="JEKBNJ+TimesNewRoman" letter_ratio="0.06"
year_ratio="0.0" cap_ratio="0.0" name_ratio="0.3" word_count="10"
lateness="0.8333333333333334" reference_score="9.53">Figure 12. Programming the
controller during the controller programming mode<component x="322.08" y="258.93"
width="238.88" height="17.89" page="5" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.05"
year_ratio="0.0" cap_ratio="0.0" name_ratio="0.4074074074074074" word_count="27"
lateness="0.8333333333333334" reference_score="8.52">Figure 13 describes the sequence
of user actions to program both the simulator and the controller. From the figure,
note the iterative nature of the joint-programming process.<component x="315.12"
y="215.98" width="256.34" height="33.0" page="5" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.08"
year_ratio="0.0" cap_ratio="0.33" name_ratio="0.09523809523809523" word_count="21"
lateness="1.0" reference_score="15.59">From the changes in controller devices' states
as described, those involved devices' states can be summarized as shown in TABLE
II.<component x="44.64" y="539.26" width="256.94" height="33.0" page="6"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="11.16" font="JEKBNJ+TimesNewRoman" letter_ratio="0.04"
year_ratio="0.0" cap_ratio="0.09" name_ratio="0.17647058823529413" word_count="85"
lateness="1.0" reference_score="11.26">From the above state table, a truth table
describing all possible logic combinations of the controller devices' states can be
derived as shown in TABLE III. In this case, user action scenarios cover all possible
combinations. Therefore, the truth table is simply the state table with redundant row
being removed. When user action scenarios do not cover all possible combinations, the
tool must ask the user for more information by displaying the missing scenarios. The
topic of generating a missing scenario is discussed elsewhere, however.<component
x="44.64" y="290.87" width="258.33" height="98.76" page="6" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.77" font="JEKBNJ+TimesNewRoman" letter_ratio="0.26"
year_ratio="0.0" cap_ratio="1.21" name_ratio="0.16346153846153846" word_count="312"
lateness="1.0" reference_score="11.67">ODES GENERATED ORRESPONDING O ISITED CENARIOS
TABLE IV. C C T V S Scenario Sensor Sensor1; Sensor Sensor2; Activator Pump1;
IF(Sensor1.State = Off &amp; Sensor2.State = Off) Pump1.State = On; Sensor2.State =
On) Pump1.State = Off; IF(Sensor1.State = On &amp; A U DND SER EMONSTRATIONS ST
generated code INPUT_VAR Sensor1:BOOL; Sensor2:BOOL; END_VAR OUTPUT_VAR Pump1:BOOL;
END_VAR IF Sensor FALSE AND Sensor 1 = 2 = FALSE THEN Pump TRUE; 1 := END_IF; IF
Sensor1 = TRUE AND Sensor2 = TRUE THEN Pump1 :=FALSE; END_IF; REFERENCES [1] Gordon
W. Paynter and Ian H. Witten, "Applying machine learning to programming by
demonstration", University of California, Riverside and University of Waikato New
Zealand, 2004. [2] Haiying She and Axel Graeser, "Closed Loop Control and Automatic
Set Point Generation in Programming by Demonstration for Service Robotic Tasks",
University of Bremen, Germany, 2004. [3] Richard M. Voyles, "Toward Gesture-Based
Programming: AgentBased Haptic Skill Acquisition and Interpretation", University of
Minnesota, 1997. [4] S. Munch, J. Kreuziger, M. Kaiser, R. Dillmann , "Robot
Programming by Demonstration (RPD) Using Machine Learning and User Interaction
Methods for the Development of Easy and Comfortable Robot Programming System",
University of Karlsruhe, Germany, 1994. [5] Tessa Lau, "Programming by Demonstration:
a Machine Learning Approach", University of Washington, 2001. [6] Lawrence D.Bergman,
Tessa A. Lau, Vittrio Castelli, Daniel Oblinger, "Programming-by-Demonstration for
Behavior-based User Interface Customization", IBM T.J. Watson research Center, USA,
2004. [7] Henry Lieberman, "Your Wish is My Command: Giving Users the Power to
Instruct their Software", Massachusetts Institute of Technology, 2000. [8] Richard G.
McDaniel, "Creating Complete User Interfaces by Demonstration", Carnegie Mellon
University, 1993. [9] Ben Shneiderman, "Foreword to Your Wish is My Command",
University of Maryland, 2000. [10] Karl-Heinz john and Michael Tiegelkamp, "ICE
61131-3 Programming Industrial Automation Systems", Springer, january 2001. [11]
Cypher, Allen, Introduction, In Cypher, Allen, ed., "Watch What I Do: Programming by
Demonstration", Cambridge: The MIT Press, 1993.<component x="315.36" y="550.77"
width="253.14" height="158.77" page="6" page_width="612.0"
page_height="792.0"></component><component x="315.12" y="89.49" width="255.41"
height="301.57" page="6" page_width="612.0"
page_height="792.0"></component></section>
  <page width="612" height="792" number="4">
    <header x="44.64" y="119.18" width="528.82" height="618.92"></header>
  </page>
</pdf>
