<?xml version="1.0"?>
<pdf>
  <title line_height="16.59" font="Helvetica-Bold">Compilation of Extended Recursion
in Call-by-Value Functional Languages</title>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.09" year_ratio="0.0"
cap_ratio="0.23" name_ratio="0.225" word_count="120" lateness="0.08333333333333333"
reference_score="7.74">ABSTRACT This paper formalizes and proves correct a
compilation scheme for mutually-recursive definitions in call-by-value functional
languages. This scheme supports a wider range of recursive definitions than standard
call-by-value recursive definitions. We formalize our technique as a translation
scheme to a lambda-calculus featuring in-place update of memory blocks, and prove the
translation to be faithful. Categories and Subject Descriptors Logics and meanings of
programs F.3.3 [ ]: Studies program and recursion schemes of program constructs- ;
Logics and meanings of programs F.3.2 [ ]: Semantics operational semantics of
programming languages- ; Programming languages D.3.1 [ ]: Formal definitions
Programming Syntax,semantics and theory- ; D.3.3 [ D.3.3 [ languages ; Compilers
Recursion Programming languages ]: Language constructs and features- ]:
Processors-<component x="53.76" y="486.24" width="239.28" height="97.62" page="1"
page_width="612.0" page_height="792.0"></component><component x="53.76" y="373.69"
width="239.2" height="97.62" page="1" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.12" year_ratio="0.0"
cap_ratio="0.36" name_ratio="0.16" word_count="75" lateness="0.08333333333333333"
reference_score="11.32">Keywords compilation, recursion, semantics, functional
languages 1. INTRODUCTION Functional languages usually feature mutually recursive
definition of values. In ML, this is supported by the let rec construct. Languages
differ, however, in the kind of expressions they allow as right-hand sides of
mutually recursive definitions. For instance, Haskell [7] allows arbitrary
expressions as right-hand sides of recursive definitions, while &#x3BB; Partially
supported by EPSRC grant GR/R 41545/01 Standard ML [13] only allows syntactic
-abstractions, and &#x2217;<component x="53.76" y="294.96" width="221.25"
height="24.42" page="1" page_width="612.0" page_height="792.0"></component><component
x="53.76" y="172.07" width="239.21" height="107.96" page="1" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.06" year_ratio="0.0"
cap_ratio="0.04" name_ratio="0.22908745247148288" word_count="1052"
lateness="0.16666666666666666" reference_score="3.61">OCaml [12, 11] allows both
-abstractions and limited forms &#x3BB; of constructor applications. Several criteria
come into play when determining the range of allowed right-hand sides. First,
languages have to give a status to ill-founded definitions such as . x = x + 1 In a
lazy language, this definition can be represented by a recursive block of code. When
its evaluation is requested, this code is executed, but it begins by requesting its
own evaluation. So, depending on the compiler, it will either loop indefinitely or
result in a run-time error. For call-by-value languages, ill-founded definitions are
more problematic: during the evaluation of , the x = x + 1 right-hand side must be
evaluated while the value of x + 1 is still unknown. There is no strict call-by-value
strategy x that allows this. Thus, such ill-founded definitions must be rejected.
Moreover, the burden recursive definitions impose to the rest of the compiler must be
taken into account. For example, one could systematically implement recursive
definitions through reference cells or thunks, but this would force the compiler to
maintain information about whether values are recursive or not. Finally, the
efficiency of the generated code is important. All these criteria interact tightly,
yielding a tension between expressiveness, efficiency, and simplicity. Recent work by
Boudol [4] introduces a call-by-value construct that is more expressive than that of
ML let rec or OCaml. In Boudol's work, right-hand sides of recursive definitions are
not syntactically restricted, but ill-founded definitions are ruled out by a type
system. This approach is further refined by Hirschowitz and Leroy [8]. Boudol and
Zimmer [5] propose an implementation technique for this extended , where recursive
definitions of let rec syntactic functions are implemented in a standard way, while
reference cells are introduced to deal with more complex recursive definitions. The
implementation of the Scheme construct proposed by Waddell et al. [15] letrec follows
the same approach. The present paper develops and proves correct a compilation scheme
and call-by-value evaluation strategy for an extended construct. This construct
suplet rec let rec ports both -abstractions and record constructions as right&#x3BB;
hand sides of recursive definitions. Moreover, it allows nonrecursive definitions to
be interleaved with recursive definitions within a single binding. The compilation
scheme let rec we propose for this flavor of let recis a generalization of the
"in-place update trick" described by Cousineau et al. [6]. It is less expressive than
that of Boudol [5], as discussed in section 7, but it is simpler and more efficient,
since it does not require the introduction of reference cells. Our main motivation in
studying this extended conlet rec struct is that it plays an important role in the
language of call-by-value mixin modules currently investigated by the authors [10].
Moreover, the OCaml compiler uses a subset of the compilation scheme described here
to compile nonfunctional recursive definitions; this paper is the first formal proof
of the correctness of this compilation scheme. The remainder of this paper is
organized as follows. In section 2, we first review informally the "in-place update
trick" [6], and show that it extends to combinations of recursive and non-recursive
bindings within the same . let rec In section 3, we formalize the corresponding
source language . Section 4 defines a target language , featuring in&#x3BB; &#x3BB;
alloc &#x25E6; place update of memory blocks. We define the compilation to in section
5, and prove its correctscheme from &#x3BB; &#x3BB; alloc &#x25E6; ness in section 6.
Related work and conclusions are discussed in sections 7 and 8. Proofs are omitted in
this paper, but can be found in a companion technical report [9]. 2. THE IN-PLACE
UPDATE TRICK The original scheme The "in-place update trick" outlined by Cousineau et
al. [6] and refined in the OCaml compiler [11], implements definitions that satisfy
the follet rec lowing two conditions. For any mutually recursive definition = = ,
first, the value of each definition should e . . . x e x 1 1 n n be represented at
run-time by a heap allocated block of statically predictable size; second, for each ,
the computation of i should not need the value of any of the definitions , but e ei j
. As an example of the second condition, only their names x j the recursive
definition is accepted, f = x.(... f ...) &#x3BB; since the computation of the
right-hand side does not need the value of . We say that it safely depends on . In
conf f trast, the recursive definition is rejected. We say f = (f 0) that the
right-hand side strictly depends on . f Evaluation of a definition with in-place
update let rec consists of three steps. First, for each definition, allocate an
uninitialized block of the expected size, and bind it to the recursively-defined
identifier. Those blocks are called dummy blocks. Second, compute the right-hand
sides of the definitions. Recursively-defined identifiers thus refer to the
corresponding dummy blocks. Owing to the second condition, no attempt is made to
access the contents of the dummy blocks. This step leads, for each definition, to a
block of the expected size. Third, the contents of the obtained blocks are copied to
the dummy blocks, updating them in place. For example, consider a mutually recursive
definition = x 1 = , where it is statically predictable that the values , x e e 1 2 2
of the expressions and will be represented at runtime by e e 1 2 heap allocated
blocks of sizes 2 and 1, respectively. Here is what the compiled code does, as
depicted in figure 1. First, it allocates two uninitialized heap blocks, at addresses
( 1 and , of respective sizes 2 and 1. This is called the pre( 2 allocation step. As
a second step, it computes e1, where and are bound to and , respectively. The result
x ( 1 x2 1 (2 is a heap block of size 2, with possible references to the two
uninitialized blocks. The same process is carried on for , resulting in a heap block
of size 1. The third and final e 2 step copies the contents of the two obtained
blocks to the two uninitialized blocks. The result is that the two initially dummy
blocks now contain the proper cyclic data structures.<component x="316.8" y="82.21"
width="239.26" height="500.22" page="1" page_width="612.0"
page_height="792.0"></component><component x="53.76" y="527.52" width="239.24"
height="206.96" page="2" page_width="612.0"
page_height="792.0"></component><component x="53.76" y="72.72" width="239.26"
height="441.42" page="2" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.05" year_ratio="0.0"
cap_ratio="0.0" name_ratio="0.20786516853932585" word_count="356"
lateness="0.16666666666666666" reference_score="2.87">The extended scheme The scheme
described above computes all definitions in sequence, and only then updates the dummy
blocks in place. From the example above, it seems quite clear that in-place update
for a definition could be done as soon as its value is available. As long as
definitions safely depend on each other, as happens with functions for instance, both
schemes behave strictly deidentically. Nevertheless, in the case where e 2 , for
example if = ( ) + 1, the original pends on fst e x x1 2 1 scheme can go wrong.
Indeed, the contents of the dummy block pre-allocated for e x1are still undefined
when is com2 puted. Instead, with immediate in-place update, the value is already
available when computing . This trivial modv e 1 2 ification to the scheme thus
increases the expressive power of . It allows definitions to de-structure the values
let rec of previous definitions. Furthermore, it allows to introduce definitions with
unknown sizes in , as shown by the let rec following example. An example of execution
is presented in figure 2. The definition is = = = , where and x e e 1 e , x e , x e1
2 2 3 3 1 3 are expected to evaluate to blocks of sizes 2 and 1, respecis tively, but
where the representation for the value of e 2 not statically predictable. The
pre-allocation step only aland . The value of is locates dummy blocks for x v e x1 3
1 1 and , which correthen computed. It can reference x x 1 3 spond to pointers to the
dummy blocks, but not , which x 2 would not make any sense here. This value is copied
to of the corresponding dummy block. Then, the value e v 2 2 is computed. The
computation can refer to both dummy . Finally, the blocks, but it can also strictly
depend on x 1 is computed and copied to the corresponding value e v3of 3 dummy block.
This modified scheme implements more mutually recursive definitions than the initial
one. The next section formalizes its semantics.<component x="316.8" y="97.68"
width="239.2" height="363.79" page="2" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.1" year_ratio="0.0"
cap_ratio="0.0" name_ratio="0.23076923076923078" word_count="13" lateness="0.25"
reference_score="4.55">e x 2 2 4. Computing and binding its value to : x<component
x="56.88" y="432.82" width="181.96" height="22.77" page="3" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.06" year_ratio="0.0"
cap_ratio="0.04" name_ratio="0.17782026768642448" word_count="523" lateness="0.25"
reference_score="4.51">3.1 Syntax The syntax of is defined in figure 3. The &#x3BB;
&#x25E6; meta-variables and range over names and variables, X x respectively. Names
are used for accessing record fields. The language includes -calculus: variables ,
abstraction &#x3BB; x , and application . The language also features &#x3BB;x.e e e 1
2 = = , record selection and a records e . . . X e e.X X 1 1 n n } { construct. A
mutually recursive definition has the let rec shape = = . let rec x e . . . x e in e
1 1 n n Syntactic correctness = Records = ( s X 1 = ) and bindings = ( = = ) are e .
. . X e b x e . . . x e 1 n n 1 1 n n required to be finite maps: a record is a
finite map from names to expressions, and a binding is a finite map from variables to
expressions. Requiring them to be finite maps means that they should not bind the
same variable or name twice. In the sequel, we refer collectively to records and
bindings as sequences, and use the usual notions on finite maps , f such as the
domain ( ), the codomain ( ), the redom f cod f striction to a set , or the
co-restriction outside of f P f P P | \ a set , which is the restriction to the set (
) . P dom f P \ Syntactic correctness of bindings includes an addilet rec tional
requirement on dependencies between definitions. In a binding = ( = = ), we say that
let rec b x e . . . x e 1 1 n n on if 1 there is a backward dependency of x i j n x i
j &#x2264; &#x2264; &#x2264; and ( ). This binding is syntactically corx FV e let rec
j i &#x2208; on , the rect only if, for any backward dependency of x x i j is of
predictable shape. An expression of preexpression e j dictable shape, written , is
either a function abstraction, a e &#x2193; record, or a binding followed by an
expression of predictable shape. (See figure 3.) Structural equivalence We consider
expressions equivalent up to alpha-conversion of variables bound in &#x3BB; is
defined as or expressions. The set of terms of let rec &#x3BB; &#x25E6; the set of
structural equivalence classes of syntactically correct expressions. 3.2 Semantics
The semantics of is quite standard, except for the treat&#x3BB; &#x25E6; ment of
bindings. let rec As shown in figure 5, values include function abstractions and
records of values , where denotes an eval&#x3BB;x.e s s v v { } = = . Notice that
variables uated record v . . . X v X 1 1 n n are also values. This is required to
allow the reduction of recursive definitions of the form = ( ) . let rec x &#x3BB;y.e
x The semantics of record selection and of function application are defined in figure
4, by computational contraction<component x="316.8" y="72.72" width="239.18"
height="493.5" page="3" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.07" font="IDOJMM+CMBX9" letter_ratio="0.03"
year_ratio="0.0" cap_ratio="0.0" name_ratio="0" word_count="3"
lateness="0.3333333333333333" reference_score="3.22">Computational reduction
rules<component x="60.0" y="638.21" width="142.63" height="8.07" page="4"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.07" font="IDOJMM+CMBX9" letter_ratio="0.1" year_ratio="0.0"
cap_ratio="0.05" name_ratio="0.13636363636363635" word_count="22"
lateness="0.3333333333333333" reference_score="6.31">) ( ) ( ( dom b dom b v &#x2229;
( b let rec b in e v ( Evaluation contexts<component x="60.0" y="548.69"
width="149.73" height="38.3" page="4" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.2" year_ratio="0.0"
cap_ratio="0.0" name_ratio="0" word_count="3" lateness="0.3333333333333333"
reference_score="7.54">( &#x222A; )<component x="209.76" y="565.08" width="6.74"
height="21.9" page="4" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.02" name_ratio="0.2056239015817223" word_count="569"
lateness="0.4166666666666667" reference_score="4.68">binding. If evaluation meets
another binding inside the expression, this binding is lifted until it is immediately
under the top-most binding. Then, it is merged with it, internally or externally
according to the context. External and internal substitutions are allowed only from
the evaluated part of the top-most binding, and when the substituted variable is in a
dereferencing context (see below). In order to simplify the presentation of the
translation and the correctness proof, we distinguish this top-most binding
syntactically: ( ( ( is a binary the global computational reduction relation c
relation on configurations , which are pairs of a binding, c the top-most binding,
and an expression, written (see b e ( figure 5). Thus, the top-most binding plays the
role of an environment, with the additional feature that values bound in this
environment can be mutually recursive. More formally, the contraction rule lifts a
Lift let rec ( binding up a lift context . As defined in figure 4, a lift context is
any nonexpression where the context hole let rec ( appears immediately under the
first node, in position of the next sub-expression to be evaluated. ( ( ( The
computational reduction relation extends the c computational contraction relation to
any evaluation con( ( , as defined in figure 4. A nested lift context is a text (
series of nested lift contexts, and an evaluation context is a nested lift context,
possibly inside the (partially evaluated) top-most binding, or under the (fully
evaluated) top-most binding. The reduction rule corresponds to internal merging. If,
IM during the evaluation of the top-most binding, one definition evaluates to a
binding, then this binding is merged with the top-most one, provided no variable
capture occurs. The evaluation can then continue. The reduction rule corresponds to
external merging. EM It is only possible at top-level, provided no variable capture
occurs. Finally, the external and internal substitution operations are modeled within
a single reduction rule . This rule Subst ( ( ( ( transforms an expression of the
shape [ [ ]] into [ [ ]], x v ( ( provided the context [ ] defines as and no variable
x v ( ranges over derefercapture occurs. The meta-variable encing contexts. A
dereferencing context is a context that expects a non-variable value to fill the hole
in order to eval( uate. An example of dereferencing context is , that is, v the
function part of a function application. An example of ( , that is, the argua
non-dereferencing context is ( ) &#x3BB;x.e ment part of a function application,
where a variable would allow the evaluation to continue. Dereferencing contexts are
formally defined in figure 4. The rule replaces a variSubst able in a dereferencing
context with its value, found in the current top-most binding. The values of the
variables bound by the top-most = is binding are accessible in two possible ways. If
b v, x e, b the partially evaluated, top-most binding, then the already can be used
for the evaluation evaluated definitions in bv of the remaining definitions,
beginning with . Otherwise, e if the top-most binding is fully evaluated, then the
bound variables can be used to evaluate the enclosed expression. Rules and in figure
4 capture these two possibilities. EA IA They implement the external and internal
substitution operations, respectively. The computational reduction relation on
expressions is compatible with structural equivalence. Hence we can de<component
x="53.76" y="109.08" width="239.24" height="625.39" page="5" page_width="612.0"
page_height="792.0"></component><component x="53.76" y="77.76" width="239.13"
height="18.56" page="5" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.5" font="IDOKHI+CMSL9" letter_ratio="0.15" year_ratio="0.0"
cap_ratio="0.64" name_ratio="0" word_count="22" lateness="0.4166666666666667"
reference_score="13.74">Configurations C Heaps &#x398; Heaps &#x2208; Answers A
Answers &#x2208; Values V Values &#x2208; H v &#x2208; Heap values S HeapValues
v<component x="324.36" y="443.41" width="82.6" height="116.23" page="5"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.97" font="IDOJOC+CMMI9" letter_ratio="0.15"
year_ratio="0.0" cap_ratio="0.23" name_ratio="0.046511627906976744" word_count="43"
lateness="0.4166666666666667" reference_score="11.75">::= &#x398; E ( Fin = Locs
HeapValues &#x2212;&#x2212;&#x2192; ::= ::= ::= ::= &#x398; V ( x ( n | | &#x3BB;x.E
S alloc n v | { } | = = 1 1 X V . . . X V n n<component x="415.92" y="443.41"
width="108.4" height="106.5" page="5" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.05" year_ratio="0.0"
cap_ratio="0.03" name_ratio="0.21498371335504887" word_count="614" lateness="0.5"
reference_score="5.52">block of size , containing unspecified data. A well-formed n
configuration is such that all the locations it mentions are bound in its heap.
Evaluated heap blocks are not values. Only integers, variables and locations are
values. In this calculus, function abstractions are not values, since their
evaluation allocates the function in the heap, and returns its location: the answer
of the evaluation of is a configuration &#x398; , where the &#x3BB;x.E ( ( location
is bound to in the heap &#x398;. ( &#x3BB;x.E The operators related to heaps are ,
which creates alloc a new empty block of the size given by its argument, and , which
overwrites the contents of its first argument update with the contents of its second
argument, provided they have the same size. To model this constraint, we assume given
a to integers. function from heap values Size H v Notations for the map equal to We
write &#x398; ( H v ( ( &#x2192;( &#x398; anywhere but on where it returns . We write
&#x398; + &#x398; ( H v 1 2 for the union of two heaps &#x398; and &#x398; whose
domains are 1 2 disjoint. In particular, when the heap &#x398; is undefined on , we
write &#x398; + to denote the union of &#x398; and ( ( H v { &#x2192;( } . ( H v {
&#x2192;( } Structural equivalence and substitutions , In &#x3BB; alloc expressions
are identified up to renaming of bound locations. Locations are bound only by heaps,
at top level in configurations. We consider configurations equal modulo renaming of
bound locations. This relation is easy to define since the location renamings never
cross any location binder. Moreover, we consider configurations equal modulo renaming
of bound variables. However, we will see that the computational reduction relation
uses a more complex notion of substitution than just variable renaming: it must also
replace variables with locations in some cases. Therefore, we consider variable
renaming as a special case of general substitutions, which we now define.
Substitutions are elements of = . Subst Vars Values &#x2192; The domain of a
substitution is the set of variables such x that ( ) = . Its codomain is the image of
its domain. We &#x3C3; x x ( write as synonymous for ( ). We often describe subx
&#x3C3; &#x3C3; x { } , implystitutions by sets of bindings V . . . x V x 1 1 n n
&#x2192;( &#x2192;( } { . We ing that their domain is included in the set . . . x x 1
n } { sometimes consider substitutions as sets, taking the union of two of them when
it makes sense, and sometimes we compose them. The composition of and is defined by
&#x3C3; &#x3C3; 1 2 = : it acts like followed by . More&#x3C3; e &#x3C3; &#x3C3;
&#x3C3; e &#x3C3; 2 1 1 2 1 &#x3C3;2 &#x25E6; } { }{ } { over, we call variable
renamings, or simply renamings, the injective substitutions whose codomains contain
only variables, and we denote them by . Symmetrically, we call &#x3B6; variable
allocations the injective substitutions mapping variables to locations, and denote
them by . &#x3B7; expressions and configWe extend substitutions to &#x3BB; alloc
urations in the usual capture-avoiding manner. A precise definition of substitution
is given in the companion technical report [9]. 4.1 Semantics The semantics of , like
the one of , is given in &#x3BB; &#x3BB;alloc &#x25E6; terms of a computational
contraction relation that handles rules for the basic constructions, and a
computational are values surrounded by a heap binding. reduction relation that
handles global rules. Evaluation answers &#x398; V ( (See figure 7.)<component
x="53.76" y="182.4" width="239.24" height="552.54" page="6" page_width="612.0"
page_height="792.0"></component><component x="53.76" y="93.72" width="239.19"
height="75.3" page="6" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.06" year_ratio="0.0"
cap_ratio="0.09" name_ratio="0.19400630914826497" word_count="634" lateness="0.5"
reference_score="7.16">tional contraction relation is defined by the rules in figure
8, using the notion of lift contexts. The rule is unusual in that it applies a heap
alloBeta cated function to an argument . The function must be a V location bound in
the heap to a value , and the result ( &#x3BB;x.E is . E x V { &#x2192;( } The rule
works similarly: it projects a name Project at location , where out of a
heap-allocated record ( X S v } { is a finite set of evaluated record field
definitions of the S v = = . The result is ( ), i.e. if shape V . . . X V S X V X 1 1
n n v i . = X X i The rule is one of the key points of . It Allocate &#x3BB; alloc
states that a value block evaluates into a fresh heap H v location containing , and a
pointer to it: &#x398; + H ( H v v { &#x2192;( } ( ( fresh). In particular, if is a
dummy block , ( ( H alloc n v the result is a dummy block on the heap. The rule
copies the contents of a heap block into Update and are respecanother heap block. If
the locations ( 1 (2 tively bound to blocks and in the heap &#x398;, then H H v v 1 2
&#x398; will evaluate to &#x398; . update ( ( ( H 1 2 1 v 2 ( ( &#x2192;( ( ( {}
Finally, as in , the evaluation of bindings is confined to &#x3BB; &#x25E6; the top
level of configurations. This requires the rule, Lift , lift which lifts a binding
outside of a lift context. In &#x3BB; alloc contexts &#x39B; are defined by ( ( ( (
&#x39B; ::= &#x3A3; = E V .X let x , B in e, | | | { } | where &#x3A3; ranges over
record contexts, of the shape &#x3A3; ::= ( = . S , X ,S v Computational reduction
relation The computational reduction relation is defined in figure 8. The rule shifts
the contraction relation to a Context nested lift context &#x3A6;. Lift contexts have
been defined in the last paragraph, and nested lift contexts are simply series of
nested lift contexts. The rule describes the top-level evaluation of bindLet ings.
Once the first definition is evaluated, the bound variable is replaced by the
obtained value in the rest of the expression. Eventually, the binding becomes empty
and can be removed with rule . EmptyLet By rule , when a heap binding is not used by
any GC other binding than itself, and not used either by the expression, it may be
removed. (The need for this rule arises from the translation scheme for definitions:
after a let rec pre-allocated block has been updated by the contents of the value of
the right-hand side expression, the top-most block of this value becomes
unreferenced. Rule allows to reGC move this top-most block entirely.) Finally, the
rule states that it is equivalent to evaluate EM two bindings in succession, or to
evaluate their union. 4.2 The calculus and its conuflence The computational reduction
relation on expressions is compatible with structural equivalence, so we can extend
it to terms, obtaining the reduction relation . &#x2212;&#x2192; Definition 2
calculus is the set of terms, The &#x3BB; alloc equipped with the relation .
&#x2212;&#x2192; , the reduction of is not deterministic Unlike in &#x3BB; &#x3BB;
alloc &#x25E6; because of rules and . Rule can apply at any GC EM GC time, and rule
gives a choice between two possibilities EM is &#x3BB; alloc when two successive
bindings are encountered. Despite this source of non-determinism, it can be shown
that confluent [9].<component x="316.8" y="72.72" width="239.22" height="661.75"
page="6" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.06" name_ratio="0.24074074074074073" word_count="108"
lateness="0.5833333333333334" reference_score="6.19">4.3 Relation to a machine
language While is presented above as an extended -calculus &#x3BB; &#x3BB; alloc with
reduction semantics, it was carefully engineered to map directly to an abstract
machine with a store, and to allow efficient compilation to machine code. In
particular, the heaps and locations used in the semantics correspond exactly to
machine-level heaps and memory addresses. (This is apparent in the requirement that
the update operation works only if the two blocks have the same size.) Actually, the
calculus is similar to a subset of one of the inter&#x3BB;alloc mediate languages
used by the OCaml compiler, from which it generates efficient native machine
code.<component x="53.76" y="279.48" width="239.2" height="127.5" page="7"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.03" name_ratio="0.2413793103448276" word_count="145"
lateness="0.5833333333333334" reference_score="5.64">5.1 The standard translation We
now define a translation from to that im&#x3BB; &#x3BB; alloc &#x25E6; plements
straightforwardly the in-place update trick. This translation, called the standard
translation, is defined in figure 9. It is straightforward for variables, functions,
applications, and record operations, but the translation of bindings is more
intricate. The translation of a binding is the conb . The first binding is catenation
of two bindings in &#x3BB; alloc called the pre-allocation binding, and gives
instructions to allocate dummy blocks on the heap for definitions of known sizes. The
second binding is called the update binding. It computes definitions, and either
updates the previously preallocated dummy blocks for definitions of known sizes, or
simply binds the result for definitions of unknown sizes. that associates Size
expression a size indication, which can be either to each &#x3BB; This translation
relies on a function &#x25E6;<component x="53.76" y="67.95" width="239.22"
height="174.27" page="7" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.05" year_ratio="0.0"
cap_ratio="0.05" name_ratio="0.19154228855721392" word_count="402"
lateness="0.5833333333333334" reference_score="6.45">an integer (a number of memory
words) or the undefined size, written [?]. This function is supposed to guess the
size of the value of the translation of its argument. We assume that the size of any
expression of predictable shape is known, and moreover that the size of variables is
undefined. In other words, ( ) = [?] for any , and Size e e Predictable &#x2193;
&#x2193; ( &#x2208; ( ) = [?] for any variable , Size x x While perfectly adequate as
a compilation scheme in an actual compiler, the standard translation does not lend
itself to a correctness proof. Such a correctness proof should be + ( ( ( ( ( ( in ,
then ; a simulation argument: if &#x3BB; e e e e &#x25E6; &#x2212;&#x2192;
&#x2212;&#x2192; ( ( moreover, if is an answer, should be an answer as well. e e
However, both properties fail. For instance, the expression , but it translates to ,
which is an answer in &#x3BB;x.x &#x3BB;x.x &#x3BB; &#x25E6; to the configuration .
reduces in ( &#x3BB;x.x ( &#x3BB; alloc { &#x2192;( } ( ( Similarly, consider = = .
If , e let rec y &#x3BB;x.x in f f f &#x2212;&#x2192; ( ( = = in the expression
reduces to let rec y &#x3BB;x.x in f e e ( . However, the translations of and are e e
&#x3BB; &#x25E6; ( ( ( ( ( = = = ( ) e let y alloc n, y update y &#x3BB;x.x in f ( (
( ( ( ( ( = = = ( ) e let y alloc n, y update y &#x3BB;x.x in f ( ( ( ( ( and does
not reduce to in : it is not possible to e e &#x3BB; alloc ( ( until the enclosing
has been reduced. reduce f let To overcome this difficulty, we are going to define
another to , called the TOP transtranslation scheme from &#x3BB; &#x3BB; alloc
&#x25E6; lation. This alternate translation is less intuitive than the standard
translation, but is easier to prove correct using a simulation argument. The
correctness of the standard translation follows from that of the TOP translation
because the standard translation of a term reduces to its TOP translation. The
intuition behind the TOP translation is that it performs "on the fly" a number of
administrative reductions over the result of the standard translation.<component
x="316.8" y="72.72" width="239.22" height="362.48" page="7" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.06" year_ratio="0.0"
cap_ratio="0.07" name_ratio="0.20692883895131087" word_count="1068"
lateness="0.6666666666666666" reference_score="7.72">These additional reductions
suffice to ensure, in particular, that answers are mapped to answers. Continuing the
example above, the TOP translation maps to the &#x3BB;x.x configuration , which is an
answer. ( &#x3BB;x.x ( { &#x2192;( } ( 5.2 Compositionality As outlined above, the
TOP translation maps expres&#x3BB; &#x25E6; sions to configurations, and not just
expressions. &#x3BB; alloc An unfortunate consequence of this requirement is that the
TOP translation cannot be compositional, in the usual sense: configurations do not
compose syntactically. For instance, the translation of an application such as ( ) (
) is not the application of the translation of &#x3BB;x.x &#x3BB;x.x the function to
the translation of the argument. To recover some degree of compositionality, we
introduce a non-standard notion of contexts in , which take as &#x3BB; alloc an
argument configurations, rather than just expressions. Contexts are pairs of a heap
and a nested lift context, and ( the application of a context &#x398; &#x3A6; to a
configuration &#x398; E ( ( ( &#x3A6;[ ]. is the configuration &#x398; + &#x398; E (
This is not sufficient, however. Recall that answers in can be of the shape .
Intuitively, should be b v b &#x3BB; v v &#x25E6; ( only contain heap translated as a
heap. But heaps of &#x3BB; alloc blocks, i.e. dummy blocks, functions or evaluated
records, can also contain definitions of the shape while the binding bv = for example
(or = 1 if featured constants), which x y x &#x3BB; &#x25E6; we do not want to
translate as heap bindings. Furthermore, we have to take into account the asymmetry
of in . let rec &#x3BB; &#x25E6; Indeed, the heap = = maps both and to the value x y,
z x x z heaps that cannot . Our solution is to retain the part of y &#x3BB; &#x25E6;
be included in heaps as substitutions. For instance, &#x3BB; alloc binding = = is
translated as the substitution the x y, z x &#x3BB; &#x25E6; . This approach
complicates the notion x y z x { &#x2192;( } &#x25E6; { &#x2192;( } of contexts: now,
they must include a substitution. Indeed, ( the context = = does not correspond to
&#x3BB; x y, z x &#x25E6; ( any standard evaluation context in . Instead, we have
&#x3BB; alloc to define a stronger kind of evaluation contexts, including a heap
&#x398;, a standard context &#x3A6;, and a substitution . We &#x3C3; write these
extended contexts &#x398; &#x3A6;[ ], and denote them &#x3C3; ( by &#x3A8;. Applying
a context to a configuration is valid if the two heaps define disjoint sets of
locations, and if the substitution carried by the context is correct for the
configuration. Fortunately, when the proposed substitution is not correct for the
considered configuration, structural equivalence allows to rename all the problematic
binders in it, and find an equivalent configuration for which the substitution is
correct. The application of a context &#x398; &#x3A6;[ ] to a configura&#x3C3; ( ( (
is the configuration (&#x398; + &#x398; &#x3A6;[ ]) . tion &#x398; E E &#x3C3; ( ( {
} &#x3A8; of two contexts &#x3A8; = Similarly, the composition &#x3A8; 1 2 i &#x25E6;
&#x398; &#x3A6; [ ] is &#x398; + &#x398; &#x3A6; [&#x3A6; ][ ], provided the
substi&#x3C3; &#x3C3; &#x3C3; i i i 1 2 1 2 1 2 ( ( &#x25E6; is correct for the heap
&#x398; +&#x398; and the context tution &#x3C3; &#x3C3; 1 2 1 2 &#x25E6; &#x3A6;
[&#x3A6; ]. Fortunately, in contexts, binders are not in po&#x3BB; 1 2 alloc sition
to capture the placeholder, so structural equivalence always allows to find correct,
equivalent contexts. 5.3 Denfiition of the TOP translation TOP translation of
expressions The TOP translation, defined in figures 10 and 11, associates
config&#x3BB; alloc urations to expressions, and configurations to &#x3BB; &#x3BB;
&#x3BB; alloc &#x25E6; &#x25E6; configurations. The idea is that the TOP translation
is used until the current point of evaluation in the expression, and beyond that
point, the standard translation is used. Variables are still translated as variables.
A function &#x3BB;x.e ( ( is translated as with the standard translation, i.e. ,
&#x3BB;x. e but the result is allocated on the heap, at a fresh location : ( ( ( . e
( ( &#x3BB;x. } ( { &#x2192;( The translation of an evaluated record takes the
translations of its fields and puts them in a record allocated on the heap at a fresh
location , obtaining &#x398; + . ( ( S ( v { &#x2192;( { }} ( Here, &#x398; is the
translation of the record , defined S s v v ( in figure 10. If = ( = = ), and for
each s X v . . . X v v 1 1 n ( n TOP ( ( , = &#x398; , then &#x398; = &#x398; ( = i v
V S X i i i v i 1 ( ( ( 1 i n &#x2264; &#x2264; = ). V . . . X V 1 n n When the
record is not fully evaluated, it is not yet allocated on the heap. It is divided
into its evaluated part , and the rest = . The part is translated as for X e, s s s v
v evaluated records, into &#x398; . The field is translated S e 1 v ( , and is
translated with the TOP translation, into &#x398; E s 2 ( ( ( the record with the
standard translation. We denote by s , translated with the standard translation. The
result is s ( ( + &#x398; = . &#x398; S , X E, s 1 2 v ( { } Function application
works like records: if the function part is not a value, then it is translated with
the TOP translation, while the argument is translated with the standard translation.
If the function is a value, then both parts are translated with the TOP translation.
The translation of a record selection consists of transe.X lating with the TOP
translation, and then selecting the e field . X TOP translation of bindings The TOP
translation of bindings is more complicated. As for records, the binding and the rest
, which is divided into its evaluated part b b v can be empty, but does not begin
with a value. The unevaluated part of the binding, , is translated as b<component
x="53.76" y="72.72" width="239.23" height="354.79" page="8" page_width="612.0"
page_height="792.0"></component><component x="316.8" y="517.08" width="239.18"
height="218.1" page="8" page_width="612.0" page_height="792.0"></component><component
x="316.8" y="72.34" width="239.24" height="433.17" page="8" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.97" font="IDOJOC+CMMI9" letter_ratio="0.27"
year_ratio="0.0" cap_ratio="0.45" name_ratio="0.05" word_count="20" lateness="0.75"
reference_score="19.58">TOP ( x TOP ( &#x3BB;x.e TOP ( s v = s , X e, s v { }
{<component x="70.44" y="637.55" width="50.73" height="60.59" page="9"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="15.56" font="IDOJMG+CMSY9" letter_ratio="0.0"
year_ratio="0.0" cap_ratio="0.0" name_ratio="0.5" word_count="2" lateness="0.75"
reference_score="4.56">( }<component x="121.2" y="637.55" width="4.61" height="15.56"
page="9" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="5.98" font="IDOKDG+CMR6" letter_ratio="0.15" year_ratio="0.0"
cap_ratio="0.25" name_ratio="0.08426966292134831" word_count="178" lateness="0.75"
reference_score="14.58">= x &#x2205; ( ( ( = ( &#x3BB;x. e ( { &#x2192;( } ( TOP ( (
= &#x398; + for = &#x398; ( S ( s v S 1 E V E E ( ( ( ( ( S v v ( { &#x2192;( { }} (
( ( e / values &#x2208; TOP ( ( ( ( = &#x398; = &#x398; + &#x398; = for s v S , X E,
s 1 2 v ( TOP ( { } ( ( = &#x398; e 2 ( TOP ( ( = &#x398; v 1 = &#x398; = &#x398; ( =
= &#x398; + &#x398; for V E 1 2 TOP ( ( = &#x398; e 2 ( ( E = &#x398; ( e / values 1
( ( for E e 2 = &#x398; TOP &#x2208; ( ( e 1 ( TOP ( ( for ( ( ( ( b ( b E.X e TOP (
( [ b ] otherwise ] if is not evaluated e &#x2205; ( ( ( [ TOP TOP e<component
x="154.68" y="556.42" width="237.47" height="140.49" page="9" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.06" year_ratio="0.0"
cap_ratio="0.09" name_ratio="0.21114369501466276" word_count="682"
lateness="0.8333333333333334" reference_score="9.21">follows. In the standard
translation, the pre-allocation pass, consists in giving instructions for allocating
dummy blocks. Here, these blocks are directly allocated by the function , which
returns the heap of dummy blocks, and the TDum substitution replacing variables with
the corresponding locations. The update pass, in the standard translation, either
updates a dummy block with the translation of the definition, or simply binds it. In
the TOP translation, the only difference is that the first definition is translated
with the TOP translation, while the remaining ones are translated with the standard
translation. The function is in TUp charge of these operations. , is translated as a
The evaluated part of the binding, b v heap and a substitution, by the function. A
definition TOP of unknown size = yields a translation of the shape x v , and is
included in the translation as the substitution V &#x2205; ( . A definition of known
size = is translated as x V x v &#x2192;( a heap and a variable allocation: has a
translation of the v shape &#x398; , and it is included in the translation of as
&#x398;, ( b v ( and the allocation . x ( &#x2192;( In practice, it is useful to
distinguish substitutions coming from definitions of unknown sizes, which can be of
any shape, from substitutions coming from definitions of known sizes, which are
allocations, and therefore have the shape . Indeed, when putting the results
together, it is x ( &#x2192;( important to take the order into account for
definitions of unknown sizes. For instance, as noticed above, a binding such as = =
generates two substitutions x y, z x x y &#x2192;( and , but the former must be
performed last. This z x &#x2192;( is why, according to the definition of , the
result is TOP . This works because, due to the syntacx y z x { &#x2192;( } &#x25E6; {
&#x2192;( } tic restrictions on , definitions of unknown sizes can let rec only be
mentioned by subsequent definitions in the binding. However, definitions of known
sizes can be mentioned by previous definitions. The key observation is that the
substitutions they generate are allocations, so they are not modified by other
substitutions, and can be performed last. is a heap &#x398;, a substitution Formally,
the translation of b v , corresponding to the definitions of unknown sizes, and
&#x3C3; an allocation , giving the locations allocated in &#x398; for the &#x3B7;
definitions of known sizes. Semantically, it corresponds to a heap &#x398; and the
substitution , and will be used as such. &#x3B7; &#x3C3; &#x25E6; The three functions
for translating bindings, , , TDum TUp and , can be viewed as contexts. The function
TOP TDum returns a heap &#x398; and an allocation , which form a con&#x3B7; ( [ ].
The function returns a heap &#x398; and a text &#x398; &#x3B7; TUp ( ( id binding ,
which form a context &#x398; [ ]. The B let B in ( function returns a heap &#x398;, a
substitution , and an TOP &#x3C3; ( ]. Notice allocation , which form a context
&#x398; [&#x3B7; &#x3C3; &#x3B7; &#x25E6; ( that the context corresponding to is not
an evaluaTUp tion context. Fortunately, the substitutions that are applied to it do
not involve the domain of its binding, thus preserving the meaning. In case the whole
binding bv, b is evaluated (i.e. is empty), then the contexts for preb allocation and
update, ( ) and ( ) are empty, and TDum b TUp b the translation of is the TOP
translation let rec b , b in e v ). Otherwise, the translation of put in the context
( e TOP b v is the standard translation of , put in of , b in e e let rec b v the
context ( ) ( ) ( ). TDum b TOP b TUp b v &#x25E6; &#x25E6; 5.4 Relating the two
translations An interesting fact is that the standard translation of any expression
reduces to its TOP translation, in any context,<component x="53.76" y="72.72"
width="239.22" height="661.75" page="10" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.08" year_ratio="0.0"
cap_ratio="0.13" name_ratio="0.16666666666666666" word_count="390"
lateness="0.8333333333333334" reference_score="10.78">Hypothesis 1 ( For al l
expressions , value , bindings e, f, e v ( ( , substitution , and context : &#x3C3;
b, b ( ( ( , then . If and ( ) = ( ) = e Size e n Size e n b e b ( &#x2022; (
&#x2212;&#x2192; If , then there exist and such that ( ) = &#x398; Size v n ( TOP
&#x2022; ( ( and . = &#x398; (&#x398;( )) = v ( Size ( n ( ( ( . implies [ ]) = ( [
]) ( ) = ( ) = ( e Size f Size e Size f n Size &#x2022; . ( ) = ( ) Size e &#x3C3;
Size e &#x2022; { } . ( ) = ( ) Size let rec b in e Size e &#x2022; Lemma 1 For al l
contexts and for al l expressions , &#x3A8; e TOP ( ( ( ( &#x2217; ] &#x3A8;[ ]
&#x3A8;[ e e . &#x2212;&#x2192; &#x2205; ( 6. CORRECTNESS OF THE TRANSLATION Owing to
their different ways of handling bindings, the and do not yield a step-by-step simtwo
languages &#x3BB; &#x3BB; alloc &#x25E6; ulation. Indeed, a redex and its reduct in
may have the &#x3BB; &#x25E6; same translation. As an example, consider two
expressions ( ( of the shape [ ] and [ ]. The let rec b in e let rec b in e v v
binding is translated as a heap &#x398; and a substitution , b &#x3C3; v in both
cases, and the fact that it is under or above the ( context is not visible in the
translation. This gives rise to a "stuttering problem": conceivably, an infinite
reduccould be translated to no reduction at tion sequence in &#x3BB; &#x25E6; , thus
changing the termination behavior of the all in &#x3BB; alloc program. In order to
ensure that this cannot happen, we prove that such silent reduction steps cannot
happen indefinitely. For this, we introduce a measure on expressions and &#xB5;
configurations that strictly decreases during silent reduction steps. Its precise
definition is given in the companion technical report [9]. Intuitively, the three
kinds of silent steps cause a decrease in a syntactic feature of the term: number of
nodes; internal or external merge steps strictly decrease the let rec<component
x="316.8" y="318.12" width="239.22" height="385.87" page="10" page_width="612.0"
page_height="792.0"></component><component x="339.24" y="289.9" width="216.57"
height="19.06" page="10" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.01" year_ratio="0.0"
cap_ratio="0.0" name_ratio="0.125" word_count="16" lateness="0.8333333333333334"
reference_score="6.32">internal or external substitution steps replace a variable
with another variable bound earlier in the expression.<component x="339.24"
y="223.92" width="216.67" height="28.99" page="10" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="15.56" font="IDOJMG+CMSY9" letter_ratio="0.12"
year_ratio="0.0" cap_ratio="0.09" name_ratio="0.11042944785276074" word_count="163"
lateness="0.8333333333333334" reference_score="11.03">The last obstacle to the
simulation theorem is the different sharing properties of the two languages. Consider
the configuration = ( = = ( ) ). It reduces by c x X &#x3BB;y.y x.X x { } ( = ( = = (
= ) ). rule to ( x X &#x3BB;y.y X &#x3BB;y.y .X x Subst c { } ( { } By the TOP
translation, is translated to a configuration ( ( c ( &#x3BB;y.y, 1 = ( ) C ( .X ( .
2 2 &#x2192;( = X ( ( 2 1 ( &#x2192;( { } ( ( ( ( ( ( ) ( .X ( . 4 2 ( ( ( ( is
translated to a configuration ( ( ( 1 ( ( ( 2 ( = C ( ( 3 ( ( ( 4 By the same
translation, c &#x3BB;y.y, &#x2192;( = X ( , 1 &#x2192;( { } &#x3BB;y.y, &#x2192;( =
X ( 3 &#x2192;( { }<component x="316.8" y="65.75" width="239.22" height="148.89"
page="10" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.06" year_ratio="0.0"
cap_ratio="0.06" name_ratio="0.17849898580121704" word_count="493"
lateness="0.9166666666666666" reference_score="9.35">The heap &#x398; of contains an
additional copy of the record ( ( C and the function. This phenomenon happens at each
application of the rule. But, except in case of a faulty Subst configuration, such a
reduction step can be followed immediately by a or a step. In our example, a Beta
Project ( (( step occurs in : reduces to = ( = = Project &#x3BB; c c x X &#x25E6; { (
) ). This reduction step destroys the copied &#x3BB;y.y &#x3BB;y.y x } ( record
immediately after it has been copied. Similarly, when a function is copied, the copy
is immediately destroyed by the subsequent reduction step. In both cases, the Beta
translated configuration reduces in one step, by the same rule ( or ). As a
consequence, our simulaProject Beta tion theorem takes this possibility into account,
and allows a couple of successive reduction steps to be simulated by a single one.
However, in the case of the rule, not only the Project record is duplicated, but also
the values it contains. In our example, the function is copied. And even after
apply&#x3BB;y.y ing the rule, it remains, as shown by the translaProject (( tion of :
( ( c ( ( ( &#x3BB;y.y, 1 &#x2192;( (( = = ( X ( , 2 1 ( ( . C 3 2 ( ( &#x2192;( { }
( &#x3BB;y.y ( 3 &#x2192;( Our solution to this problem consists in considering only
expressions where all the record fields are variables, which we R call -normal
expressions. Any expression can be transR formed into an -normal one, by applying the
following rule, in any context. NameFields ( ) i, e / Vars i, j, x / FV e i i j
&#x2203; &#x2208; &#x2200; &#x2208; (NameFields) R = = X e . . . X e 1 1 n n { }
&#x2212;&#x2192; = = let rec x e . . . x e 1 1 n n = = in X x . . . X x 1 1 n n { }
This process necessarily terminates since the number of records containing
expressions other than variables strictly obviously preserve decreases. The reduction
rules of &#x3BB; &#x25E6; R -normality. This way, after a sequence of a step Subst
followed by a step, no duplication has been made: Project an expression of the shape
has been replaced with x.X another variable. We can now state our main theorem. A
configuration &#x3BB; &#x25E6; is said to be stuck on a free variable when it is of
the shape ( ( ( [ [ ]] and ( ) is undefined. This definition is extended x x ( (
configurations (replace with &#x3A8; and with the to &#x3BB;alloc ). We say obvious
notion of dereferencing contexts for &#x3BB; alloc that a configuration is faulty if
it is in normal form and is not a valid answer and is not stuck on a free
variable.<component x="53.76" y="228.0" width="239.22" height="508.63" page="11"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.08" year_ratio="0.0"
cap_ratio="0.06" name_ratio="0.13709677419354838" word_count="124"
lateness="0.9166666666666666" reference_score="9.83">As a corollary, we obtain the
correctness of the translation. Theorem 3 (Correctness) For al l expression in e R
normal form: TOP ( ( ( ( , then . 1. If &#x2217; &#x2217; a e a e &#x2205; (
&#x2212;&#x2192; &#x2205; ( &#x2212;&#x2192; reduces to a faulty configue e &#x2205;
( ( ( ration, then also goes wrong. 2. If goes wrong, i.e. e 3. If ( . loops, i.e.
there exists an infinite reduction see ( ( quence starting from , then ( also loops.
e e &#x2205; ( 4. If gets stuck on a free variable, then so does e While our initial
goal was to prove the correctness of our compilation scheme, a completeness result
also follows from theorem 2.<component x="316.8" y="596.04" width="238.99"
height="18.56" page="11" page_width="612.0"
page_height="792.0"></component><component x="316.8" y="515.14" width="239.1"
height="66.24" page="11" page_width="612.0"
page_height="792.0"></component><component x="327.24" y="467.98" width="228.65"
height="37.77" page="11" page_width="612.0"
page_height="792.0"></component><component x="316.8" y="428.52" width="239.12"
height="29.11" page="11" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJNO+CMTI9" letter_ratio="0.14"
year_ratio="0.0" cap_ratio="0.19" name_ratio="0.19218241042345277" word_count="921"
lateness="1.0" reference_score="14.96">Remark 1 (Free variables) Free variables do
not appear during reduction. Thus, evaluation never gets stuck on a free variable if
the initial expression is closed. definitions, but does not address the issue of
efficient data representation. Benaissa et al. [3] study sharing and different
evaluation strategies, for a slightly different notion of cyclic explicit
substitution. Any term is accepted in a recursive definition, but instead of going
wrong when the recursive value is really needed, as in our system, the system of
Benaissa et al. loops. The focus of the paper is on the comparison between -graph
reduction and environment based evaluation, and &#x3BB; different evaluation
strategies. No emphasis is put on data representation either. Equational theories of
the -calculus with explicit &#x3BB; recursion Ariola et al. [2] study a -calculus
with ex&#x3BB; plicit recursion. Its semantics is given by source-to-source rewrite
rules, where is lifted to the top of terms, and let rec definitions in a binding may
use each other, as in . The &#x3BB; &#x25E6; semantics of our source language is
largely inspired by &#x3BB; &#x25E6; their call-by-value calculus. Thus, our work can
be seen as transferring the internal substitution rule IAfrom equational theory to
actual language design. Nevertheless, the concerns are different: we deal with
implementation and data representation, while Ariola et al. focus on confluence,
sharing and different evaluation strategies, including strong reduction (reduction
under -abstraction). &#x3BB; for objects and mixin modules The let rec let rec
constructs used by Boudol [4] and Hirschowitz and Leroy [8] differ from the one of in
several aspects. First, they &#x3BB; &#x25E6; accept strictly more expressions as
recursive definitions. For instance, Boudol's semantics of objects makes extensive
use generator of recursive definitions such as = ( ) . let rec o o in e Such
definitions are not allowed in . However, allows &#x3BB; &#x3BB; &#x25E6; &#x25E6; to
define in the same binding recursive values and computations using these values. The
semantics of mixin modules [10] requires complex sequences of alternate recursive .
and non-recursive bindings, which are trivial to write in &#x3BB; &#x25E6; Moreover,
compared to Boudol's language, the restrictions allow for more efficient execution,
since additional inof &#x3BB; &#x25E6; directions are avoided. 8. CONCLUSION AND
FUTURE WORK We have presented and proved correct an efficient compilation scheme for
call-by-value evaluation of mutually recursive definitions. The recursive definitions
supported by this scheme go beyond recursive functions, and include recursive data
structures, as well as the interleaving of recursive and non-recursive bindings in a
single construct. These let rec results are relevant to the efficient implementation
of callby-value mixin modules. Additionally, they formally justify the compilation
scheme for non-functional definitions let rec used in the OCaml compiler. In future
work, we plan to extend further the class of definitions supported by the compilation
scheme. let rec Consider a language where the right-hand sides of recursive
definitions are arbitrary expressions, optionally annotated with integers
representing the expected sizes for the r.h.s. expressions. This language can be
compiled exactly like : r.h.s. expressions annotated with sizes are treated &#x3BB;
&#x25E6; as having predictable shape, with pre-allocation and in-place update, while
unannotated r.h.s. expressions are handled by evaluation and binding. This language
is , since it can evaluate recursive more expressive than o generator the result of
definitions such as = &#x3BB; &#x25E6; generator ( ) provided the size of o can be
predicted. For some typed 9. REFERENCES [1] M. Abadi, L. Cardelli, P.-L. Curien, and
J.-J. Levy. J. Func. Progr. Explicit substitutions. , 1(4):375-416, 1991. [2] Z. M.
Ariola and S. Blom. Skew confluence and the Annals of pure and lambda calculus with
letrec. applied logic , 117(1-3):95-178, 2002. [3] Z.-E.-A. Benaissa, P. Lescanne,
and K. H. Rose. Modeling sharing and recursion for weak reduction Prog. Lang.,
strategies using explicit substitution. In Impl., Logics, and Programs LNCS , volume
1140 of , pages 393-407, 1996. [4] G. Boudol. The recursive record semantics of
objects Europ. Symp. on Progr. revisited. In D. Sands, editor, , LNCS volume 2028 of
, pages 269-283. Springer-Verlag, 2001. [5] G. Boudol and P. Zimmer. Recursion in the
call-by-value lambda-calculus. Fixed Points in Comp. Sc. 2002. [6] G. Cousineau,
P.-L. Curien, and M. Mauny. The Science of Computer categorical abstract machine.
Programming , 8(2):173-202, 1987. [7] The Haskell language. . http://www.haskell.org
[8] T. Hirschowitz and X. Leroy. Mixin modules in a Europ. call-by-value setting. In
D. Le Metayer, editor, Symp. on Progr. LNCS , volume 2305 of , pages 6-20, 2002. [9]
T. Hirschowitz, X. Leroy, and J. B. Wells. On the implementation of recursion in
call-by-value functional languages. Research report RR-4728, INRIA, February 2003.
[10] T. Hirschowitz, X. Leroy, and J. B. Wells. A reduction semantics for
call-by-value mixin modules. Research report RR-4682, INRIA, January 2003. [11] X.
Leroy, D. Doligez, J. Garrigue, D. Remy, and The OCaml 3.06 reference manual J.
Vouillon. , 2002. Available at . http://caml.inria.fr/ [12] X. Leroy, D. Doligez, J.
Garrigue, and J. Vouillon. The Objective Caml system. Software and documentation
available on the Web, , 1996-2003. http://caml.inria.fr/ [13] R. Milner, M. Tofte, R.
Harper, and D. MacQueen. The Definition of Standard ML (revised) . The MIT Press,
1997. [14] K. H. Rose. Explicit cyclic substitutions. In M. Rusinowitch and J.-L.
Remy, editors, CTRS '92-3rd International Workshop on Conditional Term Rewriting
Systems , volume 656 of LNCS , pages 36-50. Springer-Verlag, 1992. [15] O. Waddell,
D. Sarkar, and R. K. Dybvig. Robust and Electronic effective transformation of
letrec. In , 2002. proceedings of the 2002 Scheme Workshop .
http://scheme2002.ccs.neu.edu/<component x="316.8" y="267.25" width="239.1"
height="29.0" page="11" page_width="612.0" page_height="792.0"></component><component
x="53.76" y="339.24" width="239.33" height="395.24" page="12" page_width="612.0"
page_height="792.0"></component><component x="53.76" y="72.72" width="239.23"
height="253.14" page="12" page_width="612.0"
page_height="792.0"></component><component x="316.8" y="110.21" width="239.04"
height="570.86" page="12" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.09" year_ratio="0.0"
cap_ratio="0.23" name_ratio="0.225" word_count="120" lateness="0.08333333333333333"
reference_score="7.74">ABSTRACT This paper formalizes and proves correct a
compilation scheme for mutually-recursive definitions in call-by-value functional
languages. This scheme supports a wider range of recursive definitions than standard
call-by-value recursive definitions. We formalize our technique as a translation
scheme to a lambda-calculus featuring in-place update of memory blocks, and prove the
translation to be faithful. Categories and Subject Descriptors Logics and meanings of
programs F.3.3 [ ]: Studies program and recursion schemes of program constructs- ;
Logics and meanings of programs F.3.2 [ ]: Semantics operational semantics of
programming languages- ; Programming languages D.3.1 [ ]: Formal definitions
Programming Syntax,semantics and theory- ; D.3.3 [ D.3.3 [ languages ; Compilers
Recursion Programming languages ]: Language constructs and features- ]:
Processors-<component x="53.76" y="486.24" width="239.28" height="97.62" page="1"
page_width="612.0" page_height="792.0"></component><component x="53.76" y="373.69"
width="239.2" height="97.62" page="1" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.12" year_ratio="0.0"
cap_ratio="0.36" name_ratio="0.16" word_count="75" lateness="0.08333333333333333"
reference_score="11.32">Keywords compilation, recursion, semantics, functional
languages 1. INTRODUCTION Functional languages usually feature mutually recursive
definition of values. In ML, this is supported by the let rec construct. Languages
differ, however, in the kind of expressions they allow as right-hand sides of
mutually recursive definitions. For instance, Haskell [7] allows arbitrary
expressions as right-hand sides of recursive definitions, while &#x3BB; Partially
supported by EPSRC grant GR/R 41545/01 Standard ML [13] only allows syntactic
-abstractions, and &#x2217;<component x="53.76" y="294.96" width="221.25"
height="24.42" page="1" page_width="612.0" page_height="792.0"></component><component
x="53.76" y="172.07" width="239.21" height="107.96" page="1" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.06" year_ratio="0.0"
cap_ratio="0.04" name_ratio="0.22908745247148288" word_count="1052"
lateness="0.16666666666666666" reference_score="3.61">OCaml [12, 11] allows both
-abstractions and limited forms &#x3BB; of constructor applications. Several criteria
come into play when determining the range of allowed right-hand sides. First,
languages have to give a status to ill-founded definitions such as . x = x + 1 In a
lazy language, this definition can be represented by a recursive block of code. When
its evaluation is requested, this code is executed, but it begins by requesting its
own evaluation. So, depending on the compiler, it will either loop indefinitely or
result in a run-time error. For call-by-value languages, ill-founded definitions are
more problematic: during the evaluation of , the x = x + 1 right-hand side must be
evaluated while the value of x + 1 is still unknown. There is no strict call-by-value
strategy x that allows this. Thus, such ill-founded definitions must be rejected.
Moreover, the burden recursive definitions impose to the rest of the compiler must be
taken into account. For example, one could systematically implement recursive
definitions through reference cells or thunks, but this would force the compiler to
maintain information about whether values are recursive or not. Finally, the
efficiency of the generated code is important. All these criteria interact tightly,
yielding a tension between expressiveness, efficiency, and simplicity. Recent work by
Boudol [4] introduces a call-by-value construct that is more expressive than that of
ML let rec or OCaml. In Boudol's work, right-hand sides of recursive definitions are
not syntactically restricted, but ill-founded definitions are ruled out by a type
system. This approach is further refined by Hirschowitz and Leroy [8]. Boudol and
Zimmer [5] propose an implementation technique for this extended , where recursive
definitions of let rec syntactic functions are implemented in a standard way, while
reference cells are introduced to deal with more complex recursive definitions. The
implementation of the Scheme construct proposed by Waddell et al. [15] letrec follows
the same approach. The present paper develops and proves correct a compilation scheme
and call-by-value evaluation strategy for an extended construct. This construct
suplet rec let rec ports both -abstractions and record constructions as right&#x3BB;
hand sides of recursive definitions. Moreover, it allows nonrecursive definitions to
be interleaved with recursive definitions within a single binding. The compilation
scheme let rec we propose for this flavor of let recis a generalization of the
"in-place update trick" described by Cousineau et al. [6]. It is less expressive than
that of Boudol [5], as discussed in section 7, but it is simpler and more efficient,
since it does not require the introduction of reference cells. Our main motivation in
studying this extended conlet rec struct is that it plays an important role in the
language of call-by-value mixin modules currently investigated by the authors [10].
Moreover, the OCaml compiler uses a subset of the compilation scheme described here
to compile nonfunctional recursive definitions; this paper is the first formal proof
of the correctness of this compilation scheme. The remainder of this paper is
organized as follows. In section 2, we first review informally the "in-place update
trick" [6], and show that it extends to combinations of recursive and non-recursive
bindings within the same . let rec In section 3, we formalize the corresponding
source language . Section 4 defines a target language , featuring in&#x3BB; &#x3BB;
alloc &#x25E6; place update of memory blocks. We define the compilation to in section
5, and prove its correctscheme from &#x3BB; &#x3BB; alloc &#x25E6; ness in section 6.
Related work and conclusions are discussed in sections 7 and 8. Proofs are omitted in
this paper, but can be found in a companion technical report [9]. 2. THE IN-PLACE
UPDATE TRICK The original scheme The "in-place update trick" outlined by Cousineau et
al. [6] and refined in the OCaml compiler [11], implements definitions that satisfy
the follet rec lowing two conditions. For any mutually recursive definition = = ,
first, the value of each definition should e . . . x e x 1 1 n n be represented at
run-time by a heap allocated block of statically predictable size; second, for each ,
the computation of i should not need the value of any of the definitions , but e ei j
. As an example of the second condition, only their names x j the recursive
definition is accepted, f = x.(... f ...) &#x3BB; since the computation of the
right-hand side does not need the value of . We say that it safely depends on . In
conf f trast, the recursive definition is rejected. We say f = (f 0) that the
right-hand side strictly depends on . f Evaluation of a definition with in-place
update let rec consists of three steps. First, for each definition, allocate an
uninitialized block of the expected size, and bind it to the recursively-defined
identifier. Those blocks are called dummy blocks. Second, compute the right-hand
sides of the definitions. Recursively-defined identifiers thus refer to the
corresponding dummy blocks. Owing to the second condition, no attempt is made to
access the contents of the dummy blocks. This step leads, for each definition, to a
block of the expected size. Third, the contents of the obtained blocks are copied to
the dummy blocks, updating them in place. For example, consider a mutually recursive
definition = x 1 = , where it is statically predictable that the values , x e e 1 2 2
of the expressions and will be represented at runtime by e e 1 2 heap allocated
blocks of sizes 2 and 1, respectively. Here is what the compiled code does, as
depicted in figure 1. First, it allocates two uninitialized heap blocks, at addresses
( 1 and , of respective sizes 2 and 1. This is called the pre( 2 allocation step. As
a second step, it computes e1, where and are bound to and , respectively. The result
x ( 1 x2 1 (2 is a heap block of size 2, with possible references to the two
uninitialized blocks. The same process is carried on for , resulting in a heap block
of size 1. The third and final e 2 step copies the contents of the two obtained
blocks to the two uninitialized blocks. The result is that the two initially dummy
blocks now contain the proper cyclic data structures.<component x="316.8" y="82.21"
width="239.26" height="500.22" page="1" page_width="612.0"
page_height="792.0"></component><component x="53.76" y="527.52" width="239.24"
height="206.96" page="2" page_width="612.0"
page_height="792.0"></component><component x="53.76" y="72.72" width="239.26"
height="441.42" page="2" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.05" year_ratio="0.0"
cap_ratio="0.0" name_ratio="0.20786516853932585" word_count="356"
lateness="0.16666666666666666" reference_score="2.87">The extended scheme The scheme
described above computes all definitions in sequence, and only then updates the dummy
blocks in place. From the example above, it seems quite clear that in-place update
for a definition could be done as soon as its value is available. As long as
definitions safely depend on each other, as happens with functions for instance, both
schemes behave strictly deidentically. Nevertheless, in the case where e 2 , for
example if = ( ) + 1, the original pends on fst e x x1 2 1 scheme can go wrong.
Indeed, the contents of the dummy block pre-allocated for e x1are still undefined
when is com2 puted. Instead, with immediate in-place update, the value is already
available when computing . This trivial modv e 1 2 ification to the scheme thus
increases the expressive power of . It allows definitions to de-structure the values
let rec of previous definitions. Furthermore, it allows to introduce definitions with
unknown sizes in , as shown by the let rec following example. An example of execution
is presented in figure 2. The definition is = = = , where and x e e 1 e , x e , x e1
2 2 3 3 1 3 are expected to evaluate to blocks of sizes 2 and 1, respecis tively, but
where the representation for the value of e 2 not statically predictable. The
pre-allocation step only aland . The value of is locates dummy blocks for x v e x1 3
1 1 and , which correthen computed. It can reference x x 1 3 spond to pointers to the
dummy blocks, but not , which x 2 would not make any sense here. This value is copied
to of the corresponding dummy block. Then, the value e v 2 2 is computed. The
computation can refer to both dummy . Finally, the blocks, but it can also strictly
depend on x 1 is computed and copied to the corresponding value e v3of 3 dummy block.
This modified scheme implements more mutually recursive definitions than the initial
one. The next section formalizes its semantics.<component x="316.8" y="97.68"
width="239.2" height="363.79" page="2" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.1" year_ratio="0.0"
cap_ratio="0.0" name_ratio="0.23076923076923078" word_count="13" lateness="0.25"
reference_score="4.55">e x 2 2 4. Computing and binding its value to : x<component
x="56.88" y="432.82" width="181.96" height="22.77" page="3" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.06" year_ratio="0.0"
cap_ratio="0.04" name_ratio="0.17782026768642448" word_count="523" lateness="0.25"
reference_score="4.51">3.1 Syntax The syntax of is defined in figure 3. The &#x3BB;
&#x25E6; meta-variables and range over names and variables, X x respectively. Names
are used for accessing record fields. The language includes -calculus: variables ,
abstraction &#x3BB; x , and application . The language also features &#x3BB;x.e e e 1
2 = = , record selection and a records e . . . X e e.X X 1 1 n n } { construct. A
mutually recursive definition has the let rec shape = = . let rec x e . . . x e in e
1 1 n n Syntactic correctness = Records = ( s X 1 = ) and bindings = ( = = ) are e .
. . X e b x e . . . x e 1 n n 1 1 n n required to be finite maps: a record is a
finite map from names to expressions, and a binding is a finite map from variables to
expressions. Requiring them to be finite maps means that they should not bind the
same variable or name twice. In the sequel, we refer collectively to records and
bindings as sequences, and use the usual notions on finite maps , f such as the
domain ( ), the codomain ( ), the redom f cod f striction to a set , or the
co-restriction outside of f P f P P | \ a set , which is the restriction to the set (
) . P dom f P \ Syntactic correctness of bindings includes an addilet rec tional
requirement on dependencies between definitions. In a binding = ( = = ), we say that
let rec b x e . . . x e 1 1 n n on if 1 there is a backward dependency of x i j n x i
j &#x2264; &#x2264; &#x2264; and ( ). This binding is syntactically corx FV e let rec
j i &#x2208; on , the rect only if, for any backward dependency of x x i j is of
predictable shape. An expression of preexpression e j dictable shape, written , is
either a function abstraction, a e &#x2193; record, or a binding followed by an
expression of predictable shape. (See figure 3.) Structural equivalence We consider
expressions equivalent up to alpha-conversion of variables bound in &#x3BB; is
defined as or expressions. The set of terms of let rec &#x3BB; &#x25E6; the set of
structural equivalence classes of syntactically correct expressions. 3.2 Semantics
The semantics of is quite standard, except for the treat&#x3BB; &#x25E6; ment of
bindings. let rec As shown in figure 5, values include function abstractions and
records of values , where denotes an eval&#x3BB;x.e s s v v { } = = . Notice that
variables uated record v . . . X v X 1 1 n n are also values. This is required to
allow the reduction of recursive definitions of the form = ( ) . let rec x &#x3BB;y.e
x The semantics of record selection and of function application are defined in figure
4, by computational contraction<component x="316.8" y="72.72" width="239.18"
height="493.5" page="3" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.07" font="IDOJMM+CMBX9" letter_ratio="0.03"
year_ratio="0.0" cap_ratio="0.0" name_ratio="0" word_count="3"
lateness="0.3333333333333333" reference_score="3.22">Computational reduction
rules<component x="60.0" y="638.21" width="142.63" height="8.07" page="4"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.07" font="IDOJMM+CMBX9" letter_ratio="0.1" year_ratio="0.0"
cap_ratio="0.05" name_ratio="0.13636363636363635" word_count="22"
lateness="0.3333333333333333" reference_score="6.31">) ( ) ( ( dom b dom b v &#x2229;
( b let rec b in e v ( Evaluation contexts<component x="60.0" y="548.69"
width="149.73" height="38.3" page="4" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.2" year_ratio="0.0"
cap_ratio="0.0" name_ratio="0" word_count="3" lateness="0.3333333333333333"
reference_score="7.54">( &#x222A; )<component x="209.76" y="565.08" width="6.74"
height="21.9" page="4" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.02" name_ratio="0.2056239015817223" word_count="569"
lateness="0.4166666666666667" reference_score="4.68">binding. If evaluation meets
another binding inside the expression, this binding is lifted until it is immediately
under the top-most binding. Then, it is merged with it, internally or externally
according to the context. External and internal substitutions are allowed only from
the evaluated part of the top-most binding, and when the substituted variable is in a
dereferencing context (see below). In order to simplify the presentation of the
translation and the correctness proof, we distinguish this top-most binding
syntactically: ( ( ( is a binary the global computational reduction relation c
relation on configurations , which are pairs of a binding, c the top-most binding,
and an expression, written (see b e ( figure 5). Thus, the top-most binding plays the
role of an environment, with the additional feature that values bound in this
environment can be mutually recursive. More formally, the contraction rule lifts a
Lift let rec ( binding up a lift context . As defined in figure 4, a lift context is
any nonexpression where the context hole let rec ( appears immediately under the
first node, in position of the next sub-expression to be evaluated. ( ( ( The
computational reduction relation extends the c computational contraction relation to
any evaluation con( ( , as defined in figure 4. A nested lift context is a text (
series of nested lift contexts, and an evaluation context is a nested lift context,
possibly inside the (partially evaluated) top-most binding, or under the (fully
evaluated) top-most binding. The reduction rule corresponds to internal merging. If,
IM during the evaluation of the top-most binding, one definition evaluates to a
binding, then this binding is merged with the top-most one, provided no variable
capture occurs. The evaluation can then continue. The reduction rule corresponds to
external merging. EM It is only possible at top-level, provided no variable capture
occurs. Finally, the external and internal substitution operations are modeled within
a single reduction rule . This rule Subst ( ( ( ( transforms an expression of the
shape [ [ ]] into [ [ ]], x v ( ( provided the context [ ] defines as and no variable
x v ( ranges over derefercapture occurs. The meta-variable encing contexts. A
dereferencing context is a context that expects a non-variable value to fill the hole
in order to eval( uate. An example of dereferencing context is , that is, v the
function part of a function application. An example of ( , that is, the argua
non-dereferencing context is ( ) &#x3BB;x.e ment part of a function application,
where a variable would allow the evaluation to continue. Dereferencing contexts are
formally defined in figure 4. The rule replaces a variSubst able in a dereferencing
context with its value, found in the current top-most binding. The values of the
variables bound by the top-most = is binding are accessible in two possible ways. If
b v, x e, b the partially evaluated, top-most binding, then the already can be used
for the evaluation evaluated definitions in bv of the remaining definitions,
beginning with . Otherwise, e if the top-most binding is fully evaluated, then the
bound variables can be used to evaluate the enclosed expression. Rules and in figure
4 capture these two possibilities. EA IA They implement the external and internal
substitution operations, respectively. The computational reduction relation on
expressions is compatible with structural equivalence. Hence we can de<component
x="53.76" y="109.08" width="239.24" height="625.39" page="5" page_width="612.0"
page_height="792.0"></component><component x="53.76" y="77.76" width="239.13"
height="18.56" page="5" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.5" font="IDOKHI+CMSL9" letter_ratio="0.15" year_ratio="0.0"
cap_ratio="0.64" name_ratio="0" word_count="22" lateness="0.4166666666666667"
reference_score="13.74">Configurations C Heaps &#x398; Heaps &#x2208; Answers A
Answers &#x2208; Values V Values &#x2208; H v &#x2208; Heap values S HeapValues
v<component x="324.36" y="443.41" width="82.6" height="116.23" page="5"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.97" font="IDOJOC+CMMI9" letter_ratio="0.15"
year_ratio="0.0" cap_ratio="0.23" name_ratio="0.046511627906976744" word_count="43"
lateness="0.4166666666666667" reference_score="11.75">::= &#x398; E ( Fin = Locs
HeapValues &#x2212;&#x2212;&#x2192; ::= ::= ::= ::= &#x398; V ( x ( n | | &#x3BB;x.E
S alloc n v | { } | = = 1 1 X V . . . X V n n<component x="415.92" y="443.41"
width="108.4" height="106.5" page="5" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.05" year_ratio="0.0"
cap_ratio="0.03" name_ratio="0.21498371335504887" word_count="614" lateness="0.5"
reference_score="5.52">block of size , containing unspecified data. A well-formed n
configuration is such that all the locations it mentions are bound in its heap.
Evaluated heap blocks are not values. Only integers, variables and locations are
values. In this calculus, function abstractions are not values, since their
evaluation allocates the function in the heap, and returns its location: the answer
of the evaluation of is a configuration &#x398; , where the &#x3BB;x.E ( ( location
is bound to in the heap &#x398;. ( &#x3BB;x.E The operators related to heaps are ,
which creates alloc a new empty block of the size given by its argument, and , which
overwrites the contents of its first argument update with the contents of its second
argument, provided they have the same size. To model this constraint, we assume given
a to integers. function from heap values Size H v Notations for the map equal to We
write &#x398; ( H v ( ( &#x2192;( &#x398; anywhere but on where it returns . We write
&#x398; + &#x398; ( H v 1 2 for the union of two heaps &#x398; and &#x398; whose
domains are 1 2 disjoint. In particular, when the heap &#x398; is undefined on , we
write &#x398; + to denote the union of &#x398; and ( ( H v { &#x2192;( } . ( H v {
&#x2192;( } Structural equivalence and substitutions , In &#x3BB; alloc expressions
are identified up to renaming of bound locations. Locations are bound only by heaps,
at top level in configurations. We consider configurations equal modulo renaming of
bound locations. This relation is easy to define since the location renamings never
cross any location binder. Moreover, we consider configurations equal modulo renaming
of bound variables. However, we will see that the computational reduction relation
uses a more complex notion of substitution than just variable renaming: it must also
replace variables with locations in some cases. Therefore, we consider variable
renaming as a special case of general substitutions, which we now define.
Substitutions are elements of = . Subst Vars Values &#x2192; The domain of a
substitution is the set of variables such x that ( ) = . Its codomain is the image of
its domain. We &#x3C3; x x ( write as synonymous for ( ). We often describe subx
&#x3C3; &#x3C3; x { } , implystitutions by sets of bindings V . . . x V x 1 1 n n
&#x2192;( &#x2192;( } { . We ing that their domain is included in the set . . . x x 1
n } { sometimes consider substitutions as sets, taking the union of two of them when
it makes sense, and sometimes we compose them. The composition of and is defined by
&#x3C3; &#x3C3; 1 2 = : it acts like followed by . More&#x3C3; e &#x3C3; &#x3C3;
&#x3C3; e &#x3C3; 2 1 1 2 1 &#x3C3;2 &#x25E6; } { }{ } { over, we call variable
renamings, or simply renamings, the injective substitutions whose codomains contain
only variables, and we denote them by . Symmetrically, we call &#x3B6; variable
allocations the injective substitutions mapping variables to locations, and denote
them by . &#x3B7; expressions and configWe extend substitutions to &#x3BB; alloc
urations in the usual capture-avoiding manner. A precise definition of substitution
is given in the companion technical report [9]. 4.1 Semantics The semantics of , like
the one of , is given in &#x3BB; &#x3BB;alloc &#x25E6; terms of a computational
contraction relation that handles rules for the basic constructions, and a
computational are values surrounded by a heap binding. reduction relation that
handles global rules. Evaluation answers &#x398; V ( (See figure 7.)<component
x="53.76" y="182.4" width="239.24" height="552.54" page="6" page_width="612.0"
page_height="792.0"></component><component x="53.76" y="93.72" width="239.19"
height="75.3" page="6" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.06" year_ratio="0.0"
cap_ratio="0.09" name_ratio="0.19400630914826497" word_count="634" lateness="0.5"
reference_score="7.16">tional contraction relation is defined by the rules in figure
8, using the notion of lift contexts. The rule is unusual in that it applies a heap
alloBeta cated function to an argument . The function must be a V location bound in
the heap to a value , and the result ( &#x3BB;x.E is . E x V { &#x2192;( } The rule
works similarly: it projects a name Project at location , where out of a
heap-allocated record ( X S v } { is a finite set of evaluated record field
definitions of the S v = = . The result is ( ), i.e. if shape V . . . X V S X V X 1 1
n n v i . = X X i The rule is one of the key points of . It Allocate &#x3BB; alloc
states that a value block evaluates into a fresh heap H v location containing , and a
pointer to it: &#x398; + H ( H v v { &#x2192;( } ( ( fresh). In particular, if is a
dummy block , ( ( H alloc n v the result is a dummy block on the heap. The rule
copies the contents of a heap block into Update and are respecanother heap block. If
the locations ( 1 (2 tively bound to blocks and in the heap &#x398;, then H H v v 1 2
&#x398; will evaluate to &#x398; . update ( ( ( H 1 2 1 v 2 ( ( &#x2192;( ( ( {}
Finally, as in , the evaluation of bindings is confined to &#x3BB; &#x25E6; the top
level of configurations. This requires the rule, Lift , lift which lifts a binding
outside of a lift context. In &#x3BB; alloc contexts &#x39B; are defined by ( ( ( (
&#x39B; ::= &#x3A3; = E V .X let x , B in e, | | | { } | where &#x3A3; ranges over
record contexts, of the shape &#x3A3; ::= ( = . S , X ,S v Computational reduction
relation The computational reduction relation is defined in figure 8. The rule shifts
the contraction relation to a Context nested lift context &#x3A6;. Lift contexts have
been defined in the last paragraph, and nested lift contexts are simply series of
nested lift contexts. The rule describes the top-level evaluation of bindLet ings.
Once the first definition is evaluated, the bound variable is replaced by the
obtained value in the rest of the expression. Eventually, the binding becomes empty
and can be removed with rule . EmptyLet By rule , when a heap binding is not used by
any GC other binding than itself, and not used either by the expression, it may be
removed. (The need for this rule arises from the translation scheme for definitions:
after a let rec pre-allocated block has been updated by the contents of the value of
the right-hand side expression, the top-most block of this value becomes
unreferenced. Rule allows to reGC move this top-most block entirely.) Finally, the
rule states that it is equivalent to evaluate EM two bindings in succession, or to
evaluate their union. 4.2 The calculus and its conuflence The computational reduction
relation on expressions is compatible with structural equivalence, so we can extend
it to terms, obtaining the reduction relation . &#x2212;&#x2192; Definition 2
calculus is the set of terms, The &#x3BB; alloc equipped with the relation .
&#x2212;&#x2192; , the reduction of is not deterministic Unlike in &#x3BB; &#x3BB;
alloc &#x25E6; because of rules and . Rule can apply at any GC EM GC time, and rule
gives a choice between two possibilities EM is &#x3BB; alloc when two successive
bindings are encountered. Despite this source of non-determinism, it can be shown
that confluent [9].<component x="316.8" y="72.72" width="239.22" height="661.75"
page="6" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.03" year_ratio="0.0"
cap_ratio="0.06" name_ratio="0.24074074074074073" word_count="108"
lateness="0.5833333333333334" reference_score="6.19">4.3 Relation to a machine
language While is presented above as an extended -calculus &#x3BB; &#x3BB; alloc with
reduction semantics, it was carefully engineered to map directly to an abstract
machine with a store, and to allow efficient compilation to machine code. In
particular, the heaps and locations used in the semantics correspond exactly to
machine-level heaps and memory addresses. (This is apparent in the requirement that
the update operation works only if the two blocks have the same size.) Actually, the
calculus is similar to a subset of one of the inter&#x3BB;alloc mediate languages
used by the OCaml compiler, from which it generates efficient native machine
code.<component x="53.76" y="279.48" width="239.2" height="127.5" page="7"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.04" year_ratio="0.0"
cap_ratio="0.03" name_ratio="0.2413793103448276" word_count="145"
lateness="0.5833333333333334" reference_score="5.64">5.1 The standard translation We
now define a translation from to that im&#x3BB; &#x3BB; alloc &#x25E6; plements
straightforwardly the in-place update trick. This translation, called the standard
translation, is defined in figure 9. It is straightforward for variables, functions,
applications, and record operations, but the translation of bindings is more
intricate. The translation of a binding is the conb . The first binding is catenation
of two bindings in &#x3BB; alloc called the pre-allocation binding, and gives
instructions to allocate dummy blocks on the heap for definitions of known sizes. The
second binding is called the update binding. It computes definitions, and either
updates the previously preallocated dummy blocks for definitions of known sizes, or
simply binds the result for definitions of unknown sizes. that associates Size
expression a size indication, which can be either to each &#x3BB; This translation
relies on a function &#x25E6;<component x="53.76" y="67.95" width="239.22"
height="174.27" page="7" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.05" year_ratio="0.0"
cap_ratio="0.05" name_ratio="0.19154228855721392" word_count="402"
lateness="0.5833333333333334" reference_score="6.45">an integer (a number of memory
words) or the undefined size, written [?]. This function is supposed to guess the
size of the value of the translation of its argument. We assume that the size of any
expression of predictable shape is known, and moreover that the size of variables is
undefined. In other words, ( ) = [?] for any , and Size e e Predictable &#x2193;
&#x2193; ( &#x2208; ( ) = [?] for any variable , Size x x While perfectly adequate as
a compilation scheme in an actual compiler, the standard translation does not lend
itself to a correctness proof. Such a correctness proof should be + ( ( ( ( ( ( in ,
then ; a simulation argument: if &#x3BB; e e e e &#x25E6; &#x2212;&#x2192;
&#x2212;&#x2192; ( ( moreover, if is an answer, should be an answer as well. e e
However, both properties fail. For instance, the expression , but it translates to ,
which is an answer in &#x3BB;x.x &#x3BB;x.x &#x3BB; &#x25E6; to the configuration .
reduces in ( &#x3BB;x.x ( &#x3BB; alloc { &#x2192;( } ( ( Similarly, consider = = .
If , e let rec y &#x3BB;x.x in f f f &#x2212;&#x2192; ( ( = = in the expression
reduces to let rec y &#x3BB;x.x in f e e ( . However, the translations of and are e e
&#x3BB; &#x25E6; ( ( ( ( ( = = = ( ) e let y alloc n, y update y &#x3BB;x.x in f ( (
( ( ( ( ( = = = ( ) e let y alloc n, y update y &#x3BB;x.x in f ( ( ( ( ( and does
not reduce to in : it is not possible to e e &#x3BB; alloc ( ( until the enclosing
has been reduced. reduce f let To overcome this difficulty, we are going to define
another to , called the TOP transtranslation scheme from &#x3BB; &#x3BB; alloc
&#x25E6; lation. This alternate translation is less intuitive than the standard
translation, but is easier to prove correct using a simulation argument. The
correctness of the standard translation follows from that of the TOP translation
because the standard translation of a term reduces to its TOP translation. The
intuition behind the TOP translation is that it performs "on the fly" a number of
administrative reductions over the result of the standard translation.<component
x="316.8" y="72.72" width="239.22" height="362.48" page="7" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.06" year_ratio="0.0"
cap_ratio="0.07" name_ratio="0.20692883895131087" word_count="1068"
lateness="0.6666666666666666" reference_score="7.72">These additional reductions
suffice to ensure, in particular, that answers are mapped to answers. Continuing the
example above, the TOP translation maps to the &#x3BB;x.x configuration , which is an
answer. ( &#x3BB;x.x ( { &#x2192;( } ( 5.2 Compositionality As outlined above, the
TOP translation maps expres&#x3BB; &#x25E6; sions to configurations, and not just
expressions. &#x3BB; alloc An unfortunate consequence of this requirement is that the
TOP translation cannot be compositional, in the usual sense: configurations do not
compose syntactically. For instance, the translation of an application such as ( ) (
) is not the application of the translation of &#x3BB;x.x &#x3BB;x.x the function to
the translation of the argument. To recover some degree of compositionality, we
introduce a non-standard notion of contexts in , which take as &#x3BB; alloc an
argument configurations, rather than just expressions. Contexts are pairs of a heap
and a nested lift context, and ( the application of a context &#x398; &#x3A6; to a
configuration &#x398; E ( ( ( &#x3A6;[ ]. is the configuration &#x398; + &#x398; E (
This is not sufficient, however. Recall that answers in can be of the shape .
Intuitively, should be b v b &#x3BB; v v &#x25E6; ( only contain heap translated as a
heap. But heaps of &#x3BB; alloc blocks, i.e. dummy blocks, functions or evaluated
records, can also contain definitions of the shape while the binding bv = for example
(or = 1 if featured constants), which x y x &#x3BB; &#x25E6; we do not want to
translate as heap bindings. Furthermore, we have to take into account the asymmetry
of in . let rec &#x3BB; &#x25E6; Indeed, the heap = = maps both and to the value x y,
z x x z heaps that cannot . Our solution is to retain the part of y &#x3BB; &#x25E6;
be included in heaps as substitutions. For instance, &#x3BB; alloc binding = = is
translated as the substitution the x y, z x &#x3BB; &#x25E6; . This approach
complicates the notion x y z x { &#x2192;( } &#x25E6; { &#x2192;( } of contexts: now,
they must include a substitution. Indeed, ( the context = = does not correspond to
&#x3BB; x y, z x &#x25E6; ( any standard evaluation context in . Instead, we have
&#x3BB; alloc to define a stronger kind of evaluation contexts, including a heap
&#x398;, a standard context &#x3A6;, and a substitution . We &#x3C3; write these
extended contexts &#x398; &#x3A6;[ ], and denote them &#x3C3; ( by &#x3A8;. Applying
a context to a configuration is valid if the two heaps define disjoint sets of
locations, and if the substitution carried by the context is correct for the
configuration. Fortunately, when the proposed substitution is not correct for the
considered configuration, structural equivalence allows to rename all the problematic
binders in it, and find an equivalent configuration for which the substitution is
correct. The application of a context &#x398; &#x3A6;[ ] to a configura&#x3C3; ( ( (
is the configuration (&#x398; + &#x398; &#x3A6;[ ]) . tion &#x398; E E &#x3C3; ( ( {
} &#x3A8; of two contexts &#x3A8; = Similarly, the composition &#x3A8; 1 2 i &#x25E6;
&#x398; &#x3A6; [ ] is &#x398; + &#x398; &#x3A6; [&#x3A6; ][ ], provided the
substi&#x3C3; &#x3C3; &#x3C3; i i i 1 2 1 2 1 2 ( ( &#x25E6; is correct for the heap
&#x398; +&#x398; and the context tution &#x3C3; &#x3C3; 1 2 1 2 &#x25E6; &#x3A6;
[&#x3A6; ]. Fortunately, in contexts, binders are not in po&#x3BB; 1 2 alloc sition
to capture the placeholder, so structural equivalence always allows to find correct,
equivalent contexts. 5.3 Denfiition of the TOP translation TOP translation of
expressions The TOP translation, defined in figures 10 and 11, associates
config&#x3BB; alloc urations to expressions, and configurations to &#x3BB; &#x3BB;
&#x3BB; alloc &#x25E6; &#x25E6; configurations. The idea is that the TOP translation
is used until the current point of evaluation in the expression, and beyond that
point, the standard translation is used. Variables are still translated as variables.
A function &#x3BB;x.e ( ( is translated as with the standard translation, i.e. ,
&#x3BB;x. e but the result is allocated on the heap, at a fresh location : ( ( ( . e
( ( &#x3BB;x. } ( { &#x2192;( The translation of an evaluated record takes the
translations of its fields and puts them in a record allocated on the heap at a fresh
location , obtaining &#x398; + . ( ( S ( v { &#x2192;( { }} ( Here, &#x398; is the
translation of the record , defined S s v v ( in figure 10. If = ( = = ), and for
each s X v . . . X v v 1 1 n ( n TOP ( ( , = &#x398; , then &#x398; = &#x398; ( = i v
V S X i i i v i 1 ( ( ( 1 i n &#x2264; &#x2264; = ). V . . . X V 1 n n When the
record is not fully evaluated, it is not yet allocated on the heap. It is divided
into its evaluated part , and the rest = . The part is translated as for X e, s s s v
v evaluated records, into &#x398; . The field is translated S e 1 v ( , and is
translated with the TOP translation, into &#x398; E s 2 ( ( ( the record with the
standard translation. We denote by s , translated with the standard translation. The
result is s ( ( + &#x398; = . &#x398; S , X E, s 1 2 v ( { } Function application
works like records: if the function part is not a value, then it is translated with
the TOP translation, while the argument is translated with the standard translation.
If the function is a value, then both parts are translated with the TOP translation.
The translation of a record selection consists of transe.X lating with the TOP
translation, and then selecting the e field . X TOP translation of bindings The TOP
translation of bindings is more complicated. As for records, the binding and the rest
, which is divided into its evaluated part b b v can be empty, but does not begin
with a value. The unevaluated part of the binding, , is translated as b<component
x="53.76" y="72.72" width="239.23" height="354.79" page="8" page_width="612.0"
page_height="792.0"></component><component x="316.8" y="517.08" width="239.18"
height="218.1" page="8" page_width="612.0" page_height="792.0"></component><component
x="316.8" y="72.34" width="239.24" height="433.17" page="8" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.97" font="IDOJOC+CMMI9" letter_ratio="0.27"
year_ratio="0.0" cap_ratio="0.45" name_ratio="0.05" word_count="20" lateness="0.75"
reference_score="19.58">TOP ( x TOP ( &#x3BB;x.e TOP ( s v = s , X e, s v { }
{<component x="70.44" y="637.55" width="50.73" height="60.59" page="9"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="15.56" font="IDOJMG+CMSY9" letter_ratio="0.0"
year_ratio="0.0" cap_ratio="0.0" name_ratio="0.5" word_count="2" lateness="0.75"
reference_score="4.56">( }<component x="121.2" y="637.55" width="4.61" height="15.56"
page="9" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="5.98" font="IDOKDG+CMR6" letter_ratio="0.15" year_ratio="0.0"
cap_ratio="0.25" name_ratio="0.08426966292134831" word_count="178" lateness="0.75"
reference_score="14.58">= x &#x2205; ( ( ( = ( &#x3BB;x. e ( { &#x2192;( } ( TOP ( (
= &#x398; + for = &#x398; ( S ( s v S 1 E V E E ( ( ( ( ( S v v ( { &#x2192;( { }} (
( ( e / values &#x2208; TOP ( ( ( ( = &#x398; = &#x398; + &#x398; = for s v S , X E,
s 1 2 v ( TOP ( { } ( ( = &#x398; e 2 ( TOP ( ( = &#x398; v 1 = &#x398; = &#x398; ( =
= &#x398; + &#x398; for V E 1 2 TOP ( ( = &#x398; e 2 ( ( E = &#x398; ( e / values 1
( ( for E e 2 = &#x398; TOP &#x2208; ( ( e 1 ( TOP ( ( for ( ( ( ( b ( b E.X e TOP (
( [ b ] otherwise ] if is not evaluated e &#x2205; ( ( ( [ TOP TOP e<component
x="154.68" y="556.42" width="237.47" height="140.49" page="9" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.06" year_ratio="0.0"
cap_ratio="0.09" name_ratio="0.21114369501466276" word_count="682"
lateness="0.8333333333333334" reference_score="9.21">follows. In the standard
translation, the pre-allocation pass, consists in giving instructions for allocating
dummy blocks. Here, these blocks are directly allocated by the function , which
returns the heap of dummy blocks, and the TDum substitution replacing variables with
the corresponding locations. The update pass, in the standard translation, either
updates a dummy block with the translation of the definition, or simply binds it. In
the TOP translation, the only difference is that the first definition is translated
with the TOP translation, while the remaining ones are translated with the standard
translation. The function is in TUp charge of these operations. , is translated as a
The evaluated part of the binding, b v heap and a substitution, by the function. A
definition TOP of unknown size = yields a translation of the shape x v , and is
included in the translation as the substitution V &#x2205; ( . A definition of known
size = is translated as x V x v &#x2192;( a heap and a variable allocation: has a
translation of the v shape &#x398; , and it is included in the translation of as
&#x398;, ( b v ( and the allocation . x ( &#x2192;( In practice, it is useful to
distinguish substitutions coming from definitions of unknown sizes, which can be of
any shape, from substitutions coming from definitions of known sizes, which are
allocations, and therefore have the shape . Indeed, when putting the results
together, it is x ( &#x2192;( important to take the order into account for
definitions of unknown sizes. For instance, as noticed above, a binding such as = =
generates two substitutions x y, z x x y &#x2192;( and , but the former must be
performed last. This z x &#x2192;( is why, according to the definition of , the
result is TOP . This works because, due to the syntacx y z x { &#x2192;( } &#x25E6; {
&#x2192;( } tic restrictions on , definitions of unknown sizes can let rec only be
mentioned by subsequent definitions in the binding. However, definitions of known
sizes can be mentioned by previous definitions. The key observation is that the
substitutions they generate are allocations, so they are not modified by other
substitutions, and can be performed last. is a heap &#x398;, a substitution Formally,
the translation of b v , corresponding to the definitions of unknown sizes, and
&#x3C3; an allocation , giving the locations allocated in &#x398; for the &#x3B7;
definitions of known sizes. Semantically, it corresponds to a heap &#x398; and the
substitution , and will be used as such. &#x3B7; &#x3C3; &#x25E6; The three functions
for translating bindings, , , TDum TUp and , can be viewed as contexts. The function
TOP TDum returns a heap &#x398; and an allocation , which form a con&#x3B7; ( [ ].
The function returns a heap &#x398; and a text &#x398; &#x3B7; TUp ( ( id binding ,
which form a context &#x398; [ ]. The B let B in ( function returns a heap &#x398;, a
substitution , and an TOP &#x3C3; ( ]. Notice allocation , which form a context
&#x398; [&#x3B7; &#x3C3; &#x3B7; &#x25E6; ( that the context corresponding to is not
an evaluaTUp tion context. Fortunately, the substitutions that are applied to it do
not involve the domain of its binding, thus preserving the meaning. In case the whole
binding bv, b is evaluated (i.e. is empty), then the contexts for preb allocation and
update, ( ) and ( ) are empty, and TDum b TUp b the translation of is the TOP
translation let rec b , b in e v ). Otherwise, the translation of put in the context
( e TOP b v is the standard translation of , put in of , b in e e let rec b v the
context ( ) ( ) ( ). TDum b TOP b TUp b v &#x25E6; &#x25E6; 5.4 Relating the two
translations An interesting fact is that the standard translation of any expression
reduces to its TOP translation, in any context,<component x="53.76" y="72.72"
width="239.22" height="661.75" page="10" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.08" year_ratio="0.0"
cap_ratio="0.13" name_ratio="0.16666666666666666" word_count="390"
lateness="0.8333333333333334" reference_score="10.78">Hypothesis 1 ( For al l
expressions , value , bindings e, f, e v ( ( , substitution , and context : &#x3C3;
b, b ( ( ( , then . If and ( ) = ( ) = e Size e n Size e n b e b ( &#x2022; (
&#x2212;&#x2192; If , then there exist and such that ( ) = &#x398; Size v n ( TOP
&#x2022; ( ( and . = &#x398; (&#x398;( )) = v ( Size ( n ( ( ( . implies [ ]) = ( [
]) ( ) = ( ) = ( e Size f Size e Size f n Size &#x2022; . ( ) = ( ) Size e &#x3C3;
Size e &#x2022; { } . ( ) = ( ) Size let rec b in e Size e &#x2022; Lemma 1 For al l
contexts and for al l expressions , &#x3A8; e TOP ( ( ( ( &#x2217; ] &#x3A8;[ ]
&#x3A8;[ e e . &#x2212;&#x2192; &#x2205; ( 6. CORRECTNESS OF THE TRANSLATION Owing to
their different ways of handling bindings, the and do not yield a step-by-step simtwo
languages &#x3BB; &#x3BB; alloc &#x25E6; ulation. Indeed, a redex and its reduct in
may have the &#x3BB; &#x25E6; same translation. As an example, consider two
expressions ( ( of the shape [ ] and [ ]. The let rec b in e let rec b in e v v
binding is translated as a heap &#x398; and a substitution , b &#x3C3; v in both
cases, and the fact that it is under or above the ( context is not visible in the
translation. This gives rise to a "stuttering problem": conceivably, an infinite
reduccould be translated to no reduction at tion sequence in &#x3BB; &#x25E6; , thus
changing the termination behavior of the all in &#x3BB; alloc program. In order to
ensure that this cannot happen, we prove that such silent reduction steps cannot
happen indefinitely. For this, we introduce a measure on expressions and &#xB5;
configurations that strictly decreases during silent reduction steps. Its precise
definition is given in the companion technical report [9]. Intuitively, the three
kinds of silent steps cause a decrease in a syntactic feature of the term: number of
nodes; internal or external merge steps strictly decrease the let rec<component
x="316.8" y="318.12" width="239.22" height="385.87" page="10" page_width="612.0"
page_height="792.0"></component><component x="339.24" y="289.9" width="216.57"
height="19.06" page="10" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.01" year_ratio="0.0"
cap_ratio="0.0" name_ratio="0.125" word_count="16" lateness="0.8333333333333334"
reference_score="6.32">internal or external substitution steps replace a variable
with another variable bound earlier in the expression.<component x="339.24"
y="223.92" width="216.67" height="28.99" page="10" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="15.56" font="IDOJMG+CMSY9" letter_ratio="0.12"
year_ratio="0.0" cap_ratio="0.09" name_ratio="0.11042944785276074" word_count="163"
lateness="0.8333333333333334" reference_score="11.03">The last obstacle to the
simulation theorem is the different sharing properties of the two languages. Consider
the configuration = ( = = ( ) ). It reduces by c x X &#x3BB;y.y x.X x { } ( = ( = = (
= ) ). rule to ( x X &#x3BB;y.y X &#x3BB;y.y .X x Subst c { } ( { } By the TOP
translation, is translated to a configuration ( ( c ( &#x3BB;y.y, 1 = ( ) C ( .X ( .
2 2 &#x2192;( = X ( ( 2 1 ( &#x2192;( { } ( ( ( ( ( ( ) ( .X ( . 4 2 ( ( ( ( is
translated to a configuration ( ( ( 1 ( ( ( 2 ( = C ( ( 3 ( ( ( 4 By the same
translation, c &#x3BB;y.y, &#x2192;( = X ( , 1 &#x2192;( { } &#x3BB;y.y, &#x2192;( =
X ( 3 &#x2192;( { }<component x="316.8" y="65.75" width="239.22" height="148.89"
page="10" page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.06" year_ratio="0.0"
cap_ratio="0.06" name_ratio="0.17849898580121704" word_count="493"
lateness="0.9166666666666666" reference_score="9.35">The heap &#x398; of contains an
additional copy of the record ( ( C and the function. This phenomenon happens at each
application of the rule. But, except in case of a faulty Subst configuration, such a
reduction step can be followed immediately by a or a step. In our example, a Beta
Project ( (( step occurs in : reduces to = ( = = Project &#x3BB; c c x X &#x25E6; { (
) ). This reduction step destroys the copied &#x3BB;y.y &#x3BB;y.y x } ( record
immediately after it has been copied. Similarly, when a function is copied, the copy
is immediately destroyed by the subsequent reduction step. In both cases, the Beta
translated configuration reduces in one step, by the same rule ( or ). As a
consequence, our simulaProject Beta tion theorem takes this possibility into account,
and allows a couple of successive reduction steps to be simulated by a single one.
However, in the case of the rule, not only the Project record is duplicated, but also
the values it contains. In our example, the function is copied. And even after
apply&#x3BB;y.y ing the rule, it remains, as shown by the translaProject (( tion of :
( ( c ( ( ( &#x3BB;y.y, 1 &#x2192;( (( = = ( X ( , 2 1 ( ( . C 3 2 ( ( &#x2192;( { }
( &#x3BB;y.y ( 3 &#x2192;( Our solution to this problem consists in considering only
expressions where all the record fields are variables, which we R call -normal
expressions. Any expression can be transR formed into an -normal one, by applying the
following rule, in any context. NameFields ( ) i, e / Vars i, j, x / FV e i i j
&#x2203; &#x2208; &#x2200; &#x2208; (NameFields) R = = X e . . . X e 1 1 n n { }
&#x2212;&#x2192; = = let rec x e . . . x e 1 1 n n = = in X x . . . X x 1 1 n n { }
This process necessarily terminates since the number of records containing
expressions other than variables strictly obviously preserve decreases. The reduction
rules of &#x3BB; &#x25E6; R -normality. This way, after a sequence of a step Subst
followed by a step, no duplication has been made: Project an expression of the shape
has been replaced with x.X another variable. We can now state our main theorem. A
configuration &#x3BB; &#x25E6; is said to be stuck on a free variable when it is of
the shape ( ( ( [ [ ]] and ( ) is undefined. This definition is extended x x ( (
configurations (replace with &#x3A8; and with the to &#x3BB;alloc ). We say obvious
notion of dereferencing contexts for &#x3BB; alloc that a configuration is faulty if
it is in normal form and is not a valid answer and is not stuck on a free
variable.<component x="53.76" y="228.0" width="239.22" height="508.63" page="11"
page_width="612.0" page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJMK+CMR9" letter_ratio="0.08" year_ratio="0.0"
cap_ratio="0.06" name_ratio="0.13709677419354838" word_count="124"
lateness="0.9166666666666666" reference_score="9.83">As a corollary, we obtain the
correctness of the translation. Theorem 3 (Correctness) For al l expression in e R
normal form: TOP ( ( ( ( , then . 1. If &#x2217; &#x2217; a e a e &#x2205; (
&#x2212;&#x2192; &#x2205; ( &#x2212;&#x2192; reduces to a faulty configue e &#x2205;
( ( ( ration, then also goes wrong. 2. If goes wrong, i.e. e 3. If ( . loops, i.e.
there exists an infinite reduction see ( ( quence starting from , then ( also loops.
e e &#x2205; ( 4. If gets stuck on a free variable, then so does e While our initial
goal was to prove the correctness of our compilation scheme, a completeness result
also follows from theorem 2.<component x="316.8" y="596.04" width="238.99"
height="18.56" page="11" page_width="612.0"
page_height="792.0"></component><component x="316.8" y="515.14" width="239.1"
height="66.24" page="11" page_width="612.0"
page_height="792.0"></component><component x="327.24" y="467.98" width="228.65"
height="37.77" page="11" page_width="612.0"
page_height="792.0"></component><component x="316.8" y="428.52" width="239.12"
height="29.11" page="11" page_width="612.0"
page_height="792.0"></component></section>
  <section line_height="8.11" font="IDOJNO+CMTI9" letter_ratio="0.14"
year_ratio="0.0" cap_ratio="0.19" name_ratio="0.19218241042345277" word_count="921"
lateness="1.0" reference_score="14.96">Remark 1 (Free variables) Free variables do
not appear during reduction. Thus, evaluation never gets stuck on a free variable if
the initial expression is closed. definitions, but does not address the issue of
efficient data representation. Benaissa et al. [3] study sharing and different
evaluation strategies, for a slightly different notion of cyclic explicit
substitution. Any term is accepted in a recursive definition, but instead of going
wrong when the recursive value is really needed, as in our system, the system of
Benaissa et al. loops. The focus of the paper is on the comparison between -graph
reduction and environment based evaluation, and &#x3BB; different evaluation
strategies. No emphasis is put on data representation either. Equational theories of
the -calculus with explicit &#x3BB; recursion Ariola et al. [2] study a -calculus
with ex&#x3BB; plicit recursion. Its semantics is given by source-to-source rewrite
rules, where is lifted to the top of terms, and let rec definitions in a binding may
use each other, as in . The &#x3BB; &#x25E6; semantics of our source language is
largely inspired by &#x3BB; &#x25E6; their call-by-value calculus. Thus, our work can
be seen as transferring the internal substitution rule IAfrom equational theory to
actual language design. Nevertheless, the concerns are different: we deal with
implementation and data representation, while Ariola et al. focus on confluence,
sharing and different evaluation strategies, including strong reduction (reduction
under -abstraction). &#x3BB; for objects and mixin modules The let rec let rec
constructs used by Boudol [4] and Hirschowitz and Leroy [8] differ from the one of in
several aspects. First, they &#x3BB; &#x25E6; accept strictly more expressions as
recursive definitions. For instance, Boudol's semantics of objects makes extensive
use generator of recursive definitions such as = ( ) . let rec o o in e Such
definitions are not allowed in . However, allows &#x3BB; &#x3BB; &#x25E6; &#x25E6; to
define in the same binding recursive values and computations using these values. The
semantics of mixin modules [10] requires complex sequences of alternate recursive .
and non-recursive bindings, which are trivial to write in &#x3BB; &#x25E6; Moreover,
compared to Boudol's language, the restrictions allow for more efficient execution,
since additional inof &#x3BB; &#x25E6; directions are avoided. 8. CONCLUSION AND
FUTURE WORK We have presented and proved correct an efficient compilation scheme for
call-by-value evaluation of mutually recursive definitions. The recursive definitions
supported by this scheme go beyond recursive functions, and include recursive data
structures, as well as the interleaving of recursive and non-recursive bindings in a
single construct. These let rec results are relevant to the efficient implementation
of callby-value mixin modules. Additionally, they formally justify the compilation
scheme for non-functional definitions let rec used in the OCaml compiler. In future
work, we plan to extend further the class of definitions supported by the compilation
scheme. let rec Consider a language where the right-hand sides of recursive
definitions are arbitrary expressions, optionally annotated with integers
representing the expected sizes for the r.h.s. expressions. This language can be
compiled exactly like : r.h.s. expressions annotated with sizes are treated &#x3BB;
&#x25E6; as having predictable shape, with pre-allocation and in-place update, while
unannotated r.h.s. expressions are handled by evaluation and binding. This language
is , since it can evaluate recursive more expressive than o generator the result of
definitions such as = &#x3BB; &#x25E6; generator ( ) provided the size of o can be
predicted. For some typed 9. REFERENCES [1] M. Abadi, L. Cardelli, P.-L. Curien, and
J.-J. Levy. J. Func. Progr. Explicit substitutions. , 1(4):375-416, 1991. [2] Z. M.
Ariola and S. Blom. Skew confluence and the Annals of pure and lambda calculus with
letrec. applied logic , 117(1-3):95-178, 2002. [3] Z.-E.-A. Benaissa, P. Lescanne,
and K. H. Rose. Modeling sharing and recursion for weak reduction Prog. Lang.,
strategies using explicit substitution. In Impl., Logics, and Programs LNCS , volume
1140 of , pages 393-407, 1996. [4] G. Boudol. The recursive record semantics of
objects Europ. Symp. on Progr. revisited. In D. Sands, editor, , LNCS volume 2028 of
, pages 269-283. Springer-Verlag, 2001. [5] G. Boudol and P. Zimmer. Recursion in the
call-by-value lambda-calculus. Fixed Points in Comp. Sc. 2002. [6] G. Cousineau,
P.-L. Curien, and M. Mauny. The Science of Computer categorical abstract machine.
Programming , 8(2):173-202, 1987. [7] The Haskell language. . http://www.haskell.org
[8] T. Hirschowitz and X. Leroy. Mixin modules in a Europ. call-by-value setting. In
D. Le Metayer, editor, Symp. on Progr. LNCS , volume 2305 of , pages 6-20, 2002. [9]
T. Hirschowitz, X. Leroy, and J. B. Wells. On the implementation of recursion in
call-by-value functional languages. Research report RR-4728, INRIA, February 2003.
[10] T. Hirschowitz, X. Leroy, and J. B. Wells. A reduction semantics for
call-by-value mixin modules. Research report RR-4682, INRIA, January 2003. [11] X.
Leroy, D. Doligez, J. Garrigue, D. Remy, and The OCaml 3.06 reference manual J.
Vouillon. , 2002. Available at . http://caml.inria.fr/ [12] X. Leroy, D. Doligez, J.
Garrigue, and J. Vouillon. The Objective Caml system. Software and documentation
available on the Web, , 1996-2003. http://caml.inria.fr/ [13] R. Milner, M. Tofte, R.
Harper, and D. MacQueen. The Definition of Standard ML (revised) . The MIT Press,
1997. [14] K. H. Rose. Explicit cyclic substitutions. In M. Rusinowitch and J.-L.
Remy, editors, CTRS '92-3rd International Workshop on Conditional Term Rewriting
Systems , volume 656 of LNCS , pages 36-50. Springer-Verlag, 1992. [15] O. Waddell,
D. Sarkar, and R. K. Dybvig. Robust and Electronic effective transformation of
letrec. In , 2002. proceedings of the 2002 Scheme Workshop .
http://scheme2002.ccs.neu.edu/<component x="316.8" y="267.25" width="239.1"
height="29.0" page="11" page_width="612.0" page_height="792.0"></component><component
x="53.76" y="339.24" width="239.33" height="395.24" page="12" page_width="612.0"
page_height="792.0"></component><component x="53.76" y="72.72" width="239.23"
height="253.14" page="12" page_width="612.0"
page_height="792.0"></component><component x="316.8" y="110.21" width="239.04"
height="570.86" page="12" page_width="612.0"
page_height="792.0"></component></section>
  <page width="612" height="792" number="4">
    <header x="53.76" y="727.01" width="502.25" height="8.07"></header>
  </page>
  <page width="612" height="792" number="9">
    <header x="62.28" y="707.52" width="403.53" height="8.11"></header>
  </page>
</pdf>
